<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Convert M3U â†” TXT with Python WebAssembly - Support files up to 200MB!">
    <meta name="theme-color" content="#0f172a">
    <title>M3U/TXT Converter - Python in Browser - 200MB Support</title>
    
    <!-- ========== PWA MANIFEST ========== -->
    <link rel="manifest" href='data:application/manifest+json,{"name":"M3U Converter 200MB","short_name":"M3U Conv 200MB","start_url":"./","display":"standalone","background_color":"#0f172a","theme_color":"#0f172a","icons":[{"src":"https://img.icons8.com/color/192/000000/python.png","sizes":"192x192","type":"image/png"},{"src":"https://img.icons8.com/color/512/000000/python.png","sizes":"512x512","type":"image/png"}]}'>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="M3U Converter 200MB">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0f172a;
            color: #f1f5f9;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #cbd5e1;
            margin-bottom: 20px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 992px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background-color: #1e293b;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }
        
        .card h2 {
            color: #60a5fa;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #334155;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card h2 i {
            font-size: 1.5rem;
        }
        
        .upload-section {
            margin-bottom: 20px;
        }
        
        .upload-methods {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .upload-method {
            background-color: #334155;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .upload-method:hover {
            border-color: #3b82f6;
            transform: translateY(-5px);
        }
        
        .upload-method h3 {
            color: #93c5fd;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .upload-method h3 i {
            font-size: 1.3rem;
        }
        
        .file-upload-area {
            border: 3px dashed #475569;
            border-radius: 10px;
            padding: 25px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }
        
        .file-upload-area:hover, .file-upload-area.dragover {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.05);
        }
        
        .file-upload-area i {
            font-size: 2.2rem;
            color: #3b82f6;
            margin-bottom: 10px;
        }
        
        .file-input {
            display: none;
        }
        
        .url-input-area {
            margin-top: 10px;
        }
        
        .url-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .url-input {
            flex: 1;
            padding: 12px 15px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 8px;
            font-size: 0.95rem;
        }
        
        .url-input::placeholder {
            color: #64748b;
        }
        
        .btn {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn:hover {
            background: linear-gradient(90deg, #2563eb, #4f46e5);
            box-shadow: 0 5px 15px rgba(37, 99, 235, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(90deg, #475569, #64748b);
        }
        
        .btn-secondary:hover {
            background: linear-gradient(90deg, #374151, #4b5563);
        }
        
        .btn-small {
            padding: 8px 15px;
            font-size: 0.9rem;
        }
        
        .btn-full {
            width: 100%;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .conversion-options {
            margin: 20px 0;
            padding: 20px;
            background-color: #334155;
            border-radius: 10px;
        }
        
        .conversion-options h3 {
            color: #93c5fd;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .option-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .option-group {
            margin-bottom: 15px;
        }
        
        .option-group label {
            display: block;
            margin-bottom: 8px;
            color: #cbd5e1;
            font-weight: 500;
        }
        
        .option-group input, .option-group select, .option-group textarea {
            width: 100%;
            padding: 10px 15px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 8px;
            font-size: 0.95rem;
        }
        
        .option-group textarea {
            height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        
        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .result-area {
            margin-top: 20px;
        }
        
        textarea {
            width: 100%;
            height: 500px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            resize: vertical;
            line-height: 1.4;
        }
        
        .result-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #334155;
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #10b981;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: 400px;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.error {
            background-color: #ef4444;
        }
        
        .notification.info {
            background-color: #3b82f6;
        }
        
        .notification.warning {
            background-color: #f59e0b;
        }
        
        .notification.success {
            background-color: #10b981;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.show {
            display: block;
        }
        
        .spinner {
            border: 4px solid #334155;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #94a3b8;
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            color: #475569;
        }
        
        .python-console {
            margin-top: 20px;
            padding: 15px;
            background: #0f172a;
            border-radius: 8px;
            border: 1px solid #475569;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 250px;
            overflow-y: auto;
            line-height: 1.3;
        }
        
        .python-console .log {
            color: #cbd5e1;
            margin-bottom: 5px;
        }
        
        .python-console .error {
            color: #ef4444;
        }
        
        .python-console .success {
            color: #10b981;
        }
        
        .python-console .warning {
            color: #f59e0b;
        }
        
        .python-console .info {
            color: #60a5fa;
        }
        
        .proxy-options {
            margin-top: 15px;
            padding: 15px;
            background: #334155;
            border-radius: 8px;
        }
        
        .proxy-options h4 {
            color: #93c5fd;
            margin-bottom: 10px;
        }
        
        .proxy-select {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .proxy-option {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1;
            min-width: 120px;
        }
        
        .proxy-option input {
            margin-right: 5px;
        }
        
        .proxy-info {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-box {
            background: #334155;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #60a5fa;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #94a3b8;
        }
        
        .url-examples {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .url-examples h4 {
            color: #93c5fd;
            margin-bottom: 8px;
        }
        
        .url-list {
            list-style: none;
            padding-left: 10px;
        }
        
        .url-list li {
            margin-bottom: 5px;
            padding-left: 20px;
            position: relative;
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .url-list li:hover {
            color: #60a5fa;
        }
        
        .url-list li:before {
            content: "ðŸ”—";
            position: absolute;
            left: 0;
        }
        
        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #334155;
            border-radius: 8px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 12px;
            background: none;
            border: 2px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .mode-btn.active {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
            border-color: #3b82f6;
        }
        
        .python-runtime-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #10b981;
            font-size: 0.9rem;
            color: #94a3b8;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .python-runtime-info i {
            color: #10b981;
            font-size: 1.2rem;
        }
        
        .format-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            display: none;
        }
        
        .format-info.show {
            display: block;
        }
        
        .format-name {
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 5px;
        }
        
        .format-desc {
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .conversion-direction {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #334155;
            border-radius: 8px;
            align-items: center;
        }
        
        .direction-btn {
            flex: 1;
            padding: 12px;
            background: none;
            border: 2px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .direction-btn.active {
            background: linear-gradient(90deg, #10b981, #3b82f6);
            color: white;
            border-color: #10b981;
        }
        
        .direction-arrow {
            font-size: 1.5rem;
            color: #8b5cf6;
        }
        
        .conversion-mode {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
        }
        
        .conversion-mode span {
            font-weight: bold;
            color: #f59e0b;
        }
        
        .example-txt-content {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #94a3b8;
            font-family: 'Courier New', monospace;
            line-height: 1.3;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .cache-status {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
            font-size: 0.85rem;
            display: none;
        }
        
        .cache-status.cached {
            border-left-color: #10b981;
        }
        
        .cache-status.loading {
            border-left-color: #f59e0b;
        }
        
        .cache-status.error {
            border-left-color: #ef4444;
        }
        
        .cache-status i {
            margin-right: 8px;
            font-size: 1rem;
        }
        
        .cache-status.cached i {
            color: #10b981;
        }
        
        .cache-status.loading i {
            color: #f59e0b;
        }
        
        .cache-status.error i {
            color: #ef4444;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #334155;
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .cache-details {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .cache-details span {
            padding: 2px 6px;
            background-color: #334155;
            border-radius: 4px;
            margin-right: 5px;
        }
        
        .first-time-note {
            margin-top: 10px;
            padding: 10px;
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
            border-radius: 8px;
            border-left: 4px solid #8b5cf6;
            font-size: 0.85rem;
        }
        
        .first-time-note i {
            color: #8b5cf6;
            margin-right: 8px;
        }
        
        .offline-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #334155;
            color: #cbd5e1;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 999;
        }
        
        .offline-indicator.online {
            background-color: #10b981;
            color: white;
        }
        
        .offline-indicator.offline {
            background-color: #ef4444;
            color: white;
        }
        
        .cache-actions {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .cache-btn {
            flex: 1;
            min-width: 120px;
            padding: 8px 12px;
            background: none;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .cache-btn:hover {
            background-color: #334155;
            border-color: #3b82f6;
            color: #e2e8f0;
        }
        
        .cache-btn.clear {
            color: #ef4444;
            border-color: #ef4444;
        }
        
        .cache-btn.clear:hover {
            background-color: rgba(239, 68, 68, 0.1);
        }
        
        .cache-btn.refresh {
            color: #3b82f6;
            border-color: #3b82f6;
        }
        
        .cache-btn.refresh:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .export-options {
            margin-top: 15px;
            padding: 15px;
            background-color: #334155;
            border-radius: 8px;
        }
        
        .export-options h4 {
            color: #93c5fd;
            margin-bottom: 10px;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .export-btn {
            flex: 1;
            min-width: 100px;
            padding: 8px 12px;
            background: none;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            position: relative;
        }
        
        .export-btn:hover {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .export-btn:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: #f1f5f9;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid #334155;
        }
        
        .m3u8-info {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
        }
        
        .file-size-warning {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(245, 158, 11, 0.1);
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
            font-size: 0.85rem;
            color: #fcd34d;
            display: none;
        }
        
        .retry-button {
            margin-top: 10px;
            padding: 8px 16px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .retry-button:hover {
            background-color: #2563eb;
        }
        
        .error-details {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(239, 68, 68, 0.1);
            border-radius: 8px;
            font-size: 0.8rem;
            color: #fca5a5;
            display: none;
        }
        
        .batch-processing {
            margin-top: 15px;
            padding: 15px;
            background-color: #1e293b;
            border-radius: 8px;
            border: 1px dashed #475569;
            display: none;
        }
        
        .batch-files {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .batch-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background-color: #334155;
            margin-bottom: 5px;
            border-radius: 6px;
        }
        
        .batch-file-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            overflow: hidden;
        }
        
        .batch-file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .batch-file-size {
            font-size: 0.8rem;
            color: #94a3b8;
            min-width: 70px;
            text-align: right;
        }
        
        .batch-file-status {
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 12px;
            background-color: #475569;
            min-width: 90px;
            text-align: center;
        }
        
        .batch-file-status.ready {
            background-color: #3b82f6;
            color: white;
        }
        
        .batch-file-status.processing {
            background-color: #f59e0b;
            color: white;
        }
        
        .batch-file-status.success {
            background-color: #10b981;
            color: white;
        }
        
        .batch-file-status.error {
            background-color: #ef4444;
            color: white;
        }
        
        .batch-file-status.skipped {
            background-color: #64748b;
            color: white;
        }
        
        .batch-file-remove {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            font-size: 1rem;
            padding: 5px 8px;
            border-radius: 4px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }
        
        .batch-file-remove:hover {
            background-color: rgba(239, 68, 68, 0.1);
            transform: scale(1.1);
        }
        
        .batch-progress {
            margin-top: 15px;
        }
        
        .batch-progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .batch-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .batch-clear-btn {
            background: none;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #ef4444;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .batch-clear-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
        }
        
        .accessibility-skip {
            position: absolute;
            top: -40px;
            left: 0;
            background: #3b82f6;
            color: white;
            padding: 8px;
            border-radius: 4px;
            text-decoration: none;
            z-index: 1001;
        }
        
        .accessibility-skip:focus {
            top: 0;
        }
        
        .aria-live {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .pwa-install {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 998;
            cursor: pointer;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
            50% { box-shadow: 0 4px 20px rgba(59, 130, 246, 0.6); }
            100% { box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
        }
        
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .quick-action-btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(90deg, #475569, #64748b);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 120px;
        }
        
        .quick-action-btn:hover {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            transform: translateY(-2px);
        }
        
        .direct-download-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            font-size: 0.85rem;
            color: #94a3b8;
            display: none;
        }
        
        .direct-download-info.show {
            display: block;
        }
        
        .batch-empty {
            text-align: center;
            padding: 20px;
            color: #64748b;
            font-style: italic;
        }
        
        .batch-summary {
            margin-top: 15px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            display: none;
        }
        
        .batch-summary.show {
            display: block;
        }
        
        .copy-success {
            background: linear-gradient(90deg, #10b981, #34d399) !important;
            animation: copyPulse 0.5s ease-in-out;
        }
        
        @keyframes copyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .copy-fallback {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .copy-fallback-content {
            background: #1e293b;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .copy-fallback-textarea {
            width: 100%;
            height: 300px;
            background: #0f172a;
            color: white;
            border: 1px solid #475569;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 15px 0;
            resize: vertical;
        }
        
        .copy-fallback-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        /* PARAMETER OPTIONS STYLES */
        .parameter-options {
            margin-top: 15px;
            padding: 15px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #8b5cf6;
        }
        
        .parameter-options h4 {
            color: #93c5fd;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .parameter-search {
            margin-bottom: 15px;
        }
        
        .parameter-search-input {
            width: 100%;
            padding: 10px 15px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 8px;
            font-size: 0.95rem;
        }
        
        .parameter-search-input::placeholder {
            color: #64748b;
        }
        
        .parameter-controls {
            margin-bottom: 15px;
        }
        
        .parameter-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .parameter-action-btn {
            padding: 8px 15px;
            background: none;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .parameter-action-btn:hover {
            background-color: #334155;
            border-color: #3b82f6;
            color: #e2e8f0;
        }
        
        .parameter-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: #0f172a;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .parameter-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: #334155;
            margin-bottom: 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .parameter-item:hover {
            background-color: #3b4455;
        }
        
        .parameter-item-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .parameter-item-inputs {
            flex: 1;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .parameter-key-input {
            flex: 1;
            padding: 8px 12px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 6px;
            font-size: 0.9rem;
            min-width: 120px;
        }
        
        .parameter-key-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .parameter-value-input {
            flex: 2;
            padding: 8px 12px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 6px;
            font-size: 0.9rem;
            min-width: 200px;
        }
        
        .parameter-value-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .parameter-item-actions {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }
        
        .parameter-remove-btn {
            padding: 8px 12px;
            background: none;
            border: 1px solid #ef4444;
            color: #ef4444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .parameter-remove-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
        }
        
        .parameter-remove-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #64748b;
            color: #64748b;
        }
        
        .parameter-remove-btn:disabled:hover {
            background-color: transparent;
        }
        
        .parameter-add-section {
            margin-top: 15px;
            padding: 15px;
            background-color: #334155;
            border-radius: 8px;
        }
        
        .parameter-add-form {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .parameter-add-input {
            flex: 1;
            padding: 10px 15px;
            background-color: #0f172a;
            color: #e2e8f0;
            border: 1px solid #475569;
            border-radius: 6px;
            font-size: 0.95rem;
        }
        
        .parameter-templates {
            margin-top: 15px;
            padding: 15px;
            background-color: #334155;
            border-radius: 8px;
        }
        
        .template-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .template-btn {
            padding: 8px 15px;
            background: none;
            border: 1px solid #64748b;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .template-btn:hover {
            background-color: #475569;
            border-color: #3b82f6;
            color: #e2e8f0;
        }
        
        .template-btn.active {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .parameter-notes {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
        }
        
        /* Parameter Template Styles */
        .parameter-templates h5 {
            color: #93c5fd;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }
        
        /* ========== PARAMETER FILTER STYLES ========== */
        .parameter-filter-options {
            margin-top: 15px;
            padding: 15px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
        }
        
        .parameter-filter-options h4 {
            color: #93c5fd;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .mode-buttons-small {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .mode-btn-small {
            flex: 1;
            padding: 10px;
            background: none;
            border: 2px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .mode-btn-small.active {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
            border-color: #3b82f6;
        }
        
        .mode-btn-small:hover:not(.active) {
            background-color: #334155;
            border-color: #64748b;
        }
        
        .parameter-filter-list {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #0f172a;
            border-radius: 6px;
            margin-top: 5px;
        }
        
        .filter-param-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 5px;
            background-color: #334155;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .filter-param-item:hover {
            background-color: #3b4455;
        }
        
        .filter-param-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .filter-param-label {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .filter-param-name {
            font-weight: 500;
            color: #e2e8f0;
            font-size: 0.9rem;
        }
        
        .filter-param-value {
            font-size: 0.8rem;
            color: #94a3b8;
            word-break: break-all;
        }
        
        .filter-param-count {
            font-size: 0.75rem;
            background: #475569;
            color: #cbd5e1;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 20px;
            text-align: center;
        }
        
        .scope-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .scope-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background-color: #334155;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 150px;
        }
        
        .scope-option:hover {
            background-color: #3b4455;
        }
        
        .scope-option input[type="radio"] {
            width: 16px;
            height: 16px;
        }
        
        .filter-notes {
            margin-top: 15px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        .filter-notes ul {
            margin-top: 5px;
            margin-left: 20px;
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .filter-notes li {
            margin-bottom: 3px;
        }
        
        .filter-status {
            padding: 10px;
            background-color: #1e293b;
            border-radius: 6px;
            border-left: 4px solid #3b82f6;
            margin-top: 10px;
        }
        
        .filter-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .filter-stat {
            text-align: center;
            padding: 8px;
            background-color: #334155;
            border-radius: 6px;
        }
        
        .filter-stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #60a5fa;
        }
        
        .filter-stat-label {
            font-size: 0.8rem;
            color: #94a3b8;
        }
        
        .filter-action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .toggle-filter-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            background: none;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-filter-btn:hover {
            background-color: #334155;
            border-color: #f59e0b;
            color: #f59e0b;
        }
        
        /* PWA Mode Adjustments */
        @media (display-mode: standalone) {
            header {
                padding-top: calc(20px + env(safe-area-inset-top));
            }
            
            .container {
                min-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            }
            
            .pwa-install {
                display: none !important;
            }
        }
        
        /* PWA Install Button Animation */
        .pwa-install {
            animation: pulseInstall 2s infinite;
        }
        
        @keyframes pulseInstall {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Install Toast */
        .install-toast {
            position: fixed;
            bottom: 80px;
            left: 20px;
            right: 20px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            justify-content: space-between;
            z-index: 999;
        }
        
        .install-toast.show {
            display: flex;
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .install-toast-content {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .install-toast-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
        }
        
        /* ========== FILE INFO STYLES ========== */
        .file-info-display {
            margin-top: 15px;
            padding: 15px;
            background-color: #334155;
            border-radius: 8px;
            display: none;
        }
        
        .file-info-content {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .file-icon {
            font-size: 2rem;
            color: #3b82f6;
        }
        
        .file-details {
            flex: 1;
        }
        
        .file-name {
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 5px;
            word-break: break-all;
        }
        
        .file-meta {
            font-size: 0.9rem;
            color: #94a3b8;
        }
        
        .file-remove-btn {
            background: none;
            border: 1px solid #ef4444;
            color: #ef4444;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-remove-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
        }
        
        /* ========== DELIMITER OPTIONS STYLES ========== */
        .delimiter-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #334155;
            border-radius: 8px;
        }
        
        .delimiter-group {
            margin-bottom: 0;
        }
        
        .delimiter-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            color: #cbd5e1;
            font-weight: 500;
        }
        
        .delimiter-group label i {
            color: #60a5fa;
        }
        
        .delimiter-info {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .delimiter-info i {
            color: #f59e0b;
        }
        
        @media (max-width: 768px) {
            .delimiter-options {
                grid-template-columns: 1fr;
            }
        }
        
        /* Format Support Info */
        .format-support-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 8px;
            border-left: 4px solid #10b981;
            font-size: 0.85rem;
            color: #94a3b8;
        }
        
        .format-support-info ul {
            margin-top: 5px;
            margin-left: 20px;
            font-size: 0.8rem;
        }
        
        .format-support-info li {
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .format-support-info li i {
            color: #10b981;
            font-size: 0.7rem;
        }
        
        .format-badge {
            display: inline-block;
            padding: 2px 6px;
            background-color: #334155;
            color: #94a3b8;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-left: 5px;
        }
        
        /* Large File Support Styles */
        .large-file-support {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(90deg, rgba(37, 99, 235, 0.1), rgba(59, 130, 246, 0.1));
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
        }
        
        .large-file-support h4 {
            color: #93c5fd;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-size-info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .file-size-info {
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            text-align: center;
        }
        
        .file-size-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #60a5fa;
        }
        
        .file-size-label {
            font-size: 0.8rem;
            color: #94a3b8;
        }
        
        .memory-monitor {
            margin-top: 10px;
            padding: 10px;
            background-color: #1e293b;
            border-radius: 6px;
            border: 1px solid #475569;
        }
        
        .memory-bar {
            width: 100%;
            height: 8px;
            background-color: #334155;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .memory-used {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .memory-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
        }
        
        .file-optimization-tips {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(245, 158, 11, 0.1);
            border-radius: 6px;
            border-left: 3px solid #f59e0b;
            font-size: 0.8rem;
        }
        
        .file-optimization-tips h5 {
            color: #fcd34d;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .optimization-tip {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .optimization-tip:hover {
            background-color: rgba(245, 158, 11, 0.1);
        }
        
        .optimization-tip i {
            color: #f59e0b;
            font-size: 0.7rem;
            margin-top: 2px;
        }
        
        .optimization-tip-text {
            flex: 1;
            color: #fcd34d;
            font-size: 0.75rem;
        }
        
        .performance-warning {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background-color: rgba(239, 68, 68, 0.1);
            border-radius: 6px;
            border-left: 3px solid #ef4444;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #fca5a5;
        }
        
        .performance-warning i {
            color: #ef4444;
        }
    </style>
</head>
<body>
    <!-- Accessibility Skip Link -->
    <a href="#main-content" class="accessibility-skip" tabindex="0">
        Skip to main content
    </a>
    
    <!-- ARIA Live Region for Screen Readers -->
    <div id="aria-live" class="aria-live" aria-live="polite" aria-atomic="true"></div>
    
    <!-- PWA Install Toast -->
    <div class="install-toast" id="installToast">
        <div class="install-toast-content">
            <i class="fas fa-mobile-alt"></i>
            <span>Install app for better experience!</span>
        </div>
        <button class="install-toast-close" id="installToastClose">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <!-- Fallback Copy Modal -->
    <div class="copy-fallback" id="copyFallback">
        <div class="copy-fallback-content">
            <h3><i class="fas fa-copy"></i> Manual Copy Text</h3>
            <p>Clipboard API not available. Please copy text below manually:</p>
            <textarea class="copy-fallback-textarea" id="copyFallbackTextarea" readonly></textarea>
            <div class="copy-fallback-buttons">
                <button class="btn btn-secondary" id="copySelectAllBtn">
                    <i class="fas fa-check-double"></i> Select All
                </button>
                <button class="btn" id="copyCloseBtn">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
        </div>
    </div>
    
    <!-- PWA Install Prompt -->
    <div class="pwa-install" id="pwaInstall">
        <i class="fas fa-download"></i>
        <span>Add to Home Screen</span>
    </div>
    
    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator" aria-live="assertive">
        <i class="fas fa-wifi"></i>
        <span id="connectionStatus">Online</span>
    </div>
    
    <div class="container">
        <header>
            <h1><i class="fab fa-python"></i> M3U/TXT Converter - 200MB Support</h1>
            <p class="subtitle">Convert M3U â†” TXT with Python WebAssembly - Support files up to 200MB!</p>
            <div class="first-time-note" id="firstTimeNote">
                <i class="fas fa-info-circle"></i>
                <span><strong>NEW FEATURE:</strong> Support for files up to 200MB! Dual Delimiter & Multi-Format Support.</span>
            </div>
            
            <!-- Large File Support Info -->
            <div class="large-file-support">
                <h4><i class="fas fa-file-archive"></i> Large File Support (Max 200MB)</h4>
                <div class="file-size-info-grid">
                    <div class="file-size-info">
                        <div class="file-size-value">200MB</div>
                        <div class="file-size-label">Per File</div>
                    </div>
                    <div class="file-size-info">
                        <div class="file-size-value">500MB</div>
                        <div class="file-size-label">Total Batch</div>
                    </div>
                </div>
                <div class="memory-monitor" id="memoryMonitor">
                    <div>Memory Usage: <span id="memoryPercent">0%</span></div>
                    <div class="memory-bar">
                        <div class="memory-used" id="memoryUsedBar" style="width: 0%"></div>
                    </div>
                    <div class="memory-info">
                        <span>Used: <span id="memoryUsed">0 MB</span></span>
                        <span>Available: <span id="memoryAvailable">0 MB</span></span>
                    </div>
                </div>
            </div>
            
            <div class="format-support-info">
                <i class="fas fa-file-alt"></i>
                <strong>Supported Formats:</strong>
                <ul>
                    <li><i class="fas fa-check"></i> M3U/M3U8 <span class="format-badge">.m3u .m3u8</span></li>
                    <li><i class="fas fa-check"></i> TXT <span class="format-badge">.txt .list</span></li>
                    <li><i class="fas fa-check"></i> JSON <span class="format-badge">.json</span></li>
                    <li><i class="fas fa-check"></i> XML <span class="format-badge">.xml</span></li>
                    <li><i class="fas fa-check"></i> CSV <span class="format-badge">.csv .dat</span></li>
                    <li><i class="fas fa-check"></i> Other playlists <span class="format-badge">.ts .mpd .log</span></li>
                </ul>
            </div>
            
            <!-- File Optimization Tips -->
            <div class="file-optimization-tips">
                <h5><i class="fas fa-lightbulb"></i> Tips for Large Files:</h5>
                <div class="optimization-tip">
                    <i class="fas fa-check-circle"></i>
                    <div class="optimization-tip-text">Use Batch Mode for multiple small files</div>
                </div>
                <div class="optimization-tip">
                    <i class="fas fa-check-circle"></i>
                    <div class="optimization-tip-text">Compress files to ZIP before upload</div>
                </div>
                <div class="optimization-tip">
                    <i class="fas fa-check-circle"></i>
                    <div class="optimization-tip-text">Split large playlists into multiple files</div>
                </div>
            </div>
        </header>
        
        <main id="main-content">
            <div class="main-content">
                <div class="card">
                    <div class="mode-buttons">
                        <button class="mode-btn active" data-mode="url" aria-label="URL Mode">
                            <i class="fas fa-link"></i> URL Mode
                        </button>
                        <button class="mode-btn" data-mode="file" aria-label="File Mode">
                            <i class="fas fa-file-upload"></i> File Mode
                        </button>
                        <button class="mode-btn" data-mode="manual" aria-label="Manual Mode">
                            <i class="fas fa-keyboard"></i> Manual Mode
                        </button>
                        <button class="mode-btn" data-mode="batch" aria-label="Batch Mode">
                            <i class="fas fa-layer-group"></i> Batch Mode
                        </button>
                    </div>
                    
                    <div class="conversion-direction">
                        <button class="direction-btn active" data-direction="m3u2txt" aria-label="Convert M3U to TXT">
                            <i class="fas fa-arrow-right"></i> M3U â†’ TXT
                        </button>
                        <div class="direction-arrow">
                            <i class="fas fa-exchange-alt"></i>
                        </div>
                        <button class="direction-btn" data-direction="txt2m3u" aria-label="Convert TXT to M3U">
                            TXT â†’ M3U <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                    
                    <div class="conversion-mode">
                        Conversion Mode: <span id="conversionModeText">M3U â†’ TXT</span>
                    </div>
                    
                    <!-- DELIMITER OPTIONS SECTION -->
                    <div class="delimiter-options" id="delimiterOptions">
                        <div class="delimiter-group">
                            <label for="txtDelimiter">
                                <i class="fas fa-slash"></i> TXT Delimiter (channel-URL):
                            </label>
                            <select id="txtDelimiter" aria-label="TXT delimiter for channel-URL separation">
                                <option value=",">Comma (,)</option>
                                <option value="|">Pipe (|)</option>
                                <option value=";">Semicolon (;)</option>
                                <option value="$">Dollar ($)</option>
                                <option value="tab">Tab</option>
                            </select>
                            <div class="delimiter-info">
                                <i class="fas fa-info-circle"></i>
                                Separates channel name and URL
                            </div>
                        </div>
                        
                        <div class="delimiter-group">
                            <label for="paramDelimiter">
                                <i class="fas fa-cog"></i> Parameter Delimiter (in URL):
                            </label>
                            <select id="paramDelimiter" aria-label="Parameter delimiter within URL">
                                <option value="$">Dollar ($)</option>
                                <option value="|">Pipe (|)</option>
                                <option value=";">Semicolon (;)</option>
                                <option value="&">Ampersand (&amp;)</option>
                                <option value="#">Hash (#)</option>
                                <option value="||">Double Pipe (||)</option>
                                <option value="$$">Double Dollar ($$)</option>
                                <option value="##">Double Hash (##)</option>
                            </select>
                            <div class="delimiter-info">
                                <i class="fas fa-info-circle"></i>
                                Separates parameters within URL (key=value)
                            </div>
                        </div>
                    </div>
                    
                    <!-- PARAMETER OPTIONS SECTION -->
                    <div class="parameter-options" id="parameterOptions">
                        <h4><i class="fas fa-sliders-h"></i> Parameter Options</h4>
                        
                        <div class="parameter-search">
                            <input type="text" id="parameterSearch" class="parameter-search-input" 
                                   placeholder="Search parameters..."
                                   aria-label="Search parameters">
                        </div>
                        
                        <div class="parameter-controls">
                            <div class="parameter-actions">
                                <button class="parameter-action-btn" id="checkAllParamsBtn">
                                    <i class="fas fa-check-square"></i> Check All
                                </button>
                                <button class="parameter-action-btn" id="uncheckAllParamsBtn">
                                    <i class="fas fa-square"></i> Uncheck All
                                </button>
                                <button class="parameter-action-btn" id="enableAllParamsBtn">
                                    <i class="fas fa-toggle-on"></i> Enable All
                                </button>
                                <button class="parameter-action-btn" id="disableAllParamsBtn">
                                    <i class="fas fa-toggle-off"></i> Disable All
                                </button>
                            </div>
                            
                            <div class="parameter-list" id="parameterList">
                                <!-- Parameter items will be generated by JavaScript -->
                            </div>
                        </div>
                        
                        <div class="parameter-add-section">
                            <h5><i class="fas fa-plus-circle"></i> Add New Parameter</h5>
                            <div class="parameter-add-form">
                                <input type="text" id="newParamKey" class="parameter-add-input" 
                                       placeholder="Parameter key (e.g., User-Agent)"
                                       aria-label="New parameter key">
                                <input type="text" id="newParamValue" class="parameter-add-input" 
                                       placeholder="Parameter value (e.g., Mozilla/5.0)"
                                       aria-label="New parameter value">
                                <button class="btn btn-small" id="addNewParamBtn">
                                    <i class="fas fa-plus"></i> Add
                                </button>
                            </div>
                        </div>
                        
                        <div class="parameter-templates">
                            <h5><i class="fas fa-lightbulb"></i> Parameter Templates:</h5>
                            <div class="template-buttons" id="templateButtons">
                                <!-- Template buttons will be generated by JavaScript -->
                            </div>
                        </div>
                        
                        <div class="parameter-notes">
                            <i class="fas fa-info-circle"></i> 
                            <strong>Note:</strong> Checked parameters will be added to all channels. 
                            Parameters will be separated with <strong id="currentParamDelimiter">$</strong> in URL.
                        </div>
                    </div>
                    
                    <!-- PARAMETER FILTER OPTIONS SECTION -->
                    <div class="parameter-filter-options" id="parameterFilterOptions">
                        <h4><i class="fas fa-filter"></i> Parameter Filter Options</h4>
                        
                        <button class="toggle-filter-btn" id="toggleFilterBtn">
                            <i class="fas fa-eye-slash"></i> Show/Hide Filter Options
                        </button>
                        
                        <div id="filterOptionsContent" style="margin-top: 15px;">
                            <div class="filter-mode-selector">
                                <label style="display: block; margin-bottom: 10px; color: #cbd5e1; font-weight: 500;">
                                    <i class="fas fa-cog"></i> Filter Mode:
                                </label>
                                <div class="mode-buttons-small">
                                    <button class="mode-btn-small active" data-filter-mode="keep" aria-label="Keep selected parameters">
                                        <i class="fas fa-check-circle"></i> Keep Selected
                                    </button>
                                    <button class="mode-btn-small" data-filter-mode="remove" aria-label="Remove selected parameters">
                                        <i class="fas fa-times-circle"></i> Remove Selected
                                    </button>
                                    <button class="mode-btn-small" data-filter-mode="regex" aria-label="Filter with regex">
                                        <i class="fas fa-code"></i> Regex Filter
                                    </button>
                                </div>
                            </div>
                            
                            <div class="filter-options" id="filterOptionsKeep" style="margin-top: 15px;">
                                <div class="option-group">
                                    <label for="parameterFilterSelect">
                                        <i class="fas fa-list-check"></i> Select parameters to keep/remove:
                                    </label>
                                    <div class="parameter-filter-list" id="parameterFilterList">
                                        <!-- Parameter list will be populated dynamically -->
                                    </div>
                                </div>
                            </div>
                            
                            <div class="filter-options" id="filterOptionsRegex" style="margin-top: 15px; display: none;">
                                <div class="option-group">
                                    <label for="regexPattern">
                                        <i class="fas fa-terminal"></i> Regex Pattern:
                                    </label>
                                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                        <input type="text" id="regexPattern" class="url-input" 
                                               placeholder="Example: ^(User-Agent|Referer)$ or ^license.*"
                                               style="flex: 1;">
                                        <button class="btn btn-small" id="testRegexBtn" aria-label="Test regex pattern">
                                            <i class="fas fa-vial"></i> Test
                                        </button>
                                    </div>
                                    <div class="regex-test-result" id="regexTestResult" style="display: none;">
                                        <div style="padding: 8px; background: #1e293b; border-radius: 6px;">
                                            <span style="color: #94a3b8;">Regex result: </span>
                                            <span id="regexResultText"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="filter-scope" style="margin-top: 15px;">
                                <label style="display: block; margin-bottom: 10px; color: #cbd5e1; font-weight: 500;">
                                    <i class="fas fa-project-diagram"></i> Filter Scope:
                                </label>
                                <div class="scope-buttons">
                                    <label class="scope-option">
                                        <input type="radio" name="filterScope" value="all" checked>
                                        <i class="fas fa-globe"></i> Apply to all channels
                                    </label>
                                    <label class="scope-option">
                                        <input type="radio" name="filterScope" value="selected">
                                        <i class="fas fa-mouse-pointer"></i> Only selected channels
                                    </label>
                                    <label class="scope-option">
                                        <input type="radio" name="filterScope" value="regex">
                                        <i class="fas fa-font"></i> Based on channel name (regex)
                                    </label>
                                </div>
                                
                                <div class="channel-regex-input" id="channelRegexInput" style="margin-top: 10px; display: none;">
                                    <input type="text" id="channelNamePattern" class="url-input" 
                                           placeholder="Example: ^SPORTS.* or .*MOVIES.*"
                                           style="width: 100%;">
                                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 5px;">
                                        <i class="fas fa-info-circle"></i> Regex pattern for channel names
                                    </div>
                                </div>
                            </div>
                            
                            <div class="filter-notes">
                                <i class="fas fa-lightbulb"></i>
                                <strong>Filter Tips:</strong>
                                <ul>
                                    <li><strong>Keep Selected</strong>: Only checked parameters will be kept</li>
                                    <li><strong>Remove Selected</strong>: Checked parameters will be removed</li>
                                    <li><strong>Regex</strong>: Use regex patterns for flexible filtering</li>
                                </ul>
                            </div>
                            
                            <div class="action-buttons" style="margin-top: 15px;">
                                <button class="btn btn-secondary" id="analyzeParamsBtn">
                                    <i class="fas fa-chart-bar"></i> Analyze Parameters
                                </button>
                                <button class="btn btn-secondary" id="applyFilterBtn">
                                    <i class="fas fa-filter"></i> Apply Filter
                                </button>
                                <button class="btn btn-secondary" id="resetFilterBtn">
                                    <i class="fas fa-undo"></i> Reset Filter
                                </button>
                            </div>
                            
                            <div class="filter-status" id="filterStatus" style="margin-top: 10px; display: none;">
                                <!-- Filter status will be displayed here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- URL Mode -->
                    <div id="urlMode" class="upload-section">
                        <h2><i class="fas fa-download"></i> Download from URL</h2>
                        
                        <div class="url-input-area">
                            <div class="url-input-group">
                                <input type="url" id="urlInput" class="url-input" 
                                       placeholder="http://example.com/playlist.m3u" 
                                       value=""
                                       aria-label="Playlist URL">
                                <button class="btn btn-small" id="fetchBtn" aria-label="Fetch URL">
                                    <i class="fas fa-download"></i> Fetch
                                </button>
                            </div>
                            
                            <!-- Quick Actions Bar -->
                            <div class="quick-actions">
                                <button class="quick-action-btn" id="directDownloadBtn">
                                    <i class="fas fa-file-download"></i> Direct Download
                                </button>
                            </div>
                            
                            <div class="direct-download-info" id="directDownloadInfo">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span><i class="fas fa-info-circle"></i> File will be downloaded directly without conversion</span>
                                    <button class="btn btn-small" id="cancelDownloadBtn" style="background: #ef4444;">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                                <div class="progress-bar" style="margin-top: 8px;">
                                    <div class="progress-fill" id="downloadProgress"></div>
                                </div>
                                <div style="font-size: 0.8rem; margin-top: 5px;">
                                    Status: <span id="downloadStatus">Waiting...</span>
                                </div>
                            </div>
                            
                            <div class="proxy-options">
                                <h4><i class="fas fa-satellite-dish"></i> Data Fetching Methods:</h4>
                                <div class="proxy-select" id="proxySelect">
                                    <label class="proxy-option">
                                        <input type="radio" name="proxyMethod" value="auto" checked>
                                        <i class="fas fa-robot"></i> Auto (Try all)
                                    </label>
                                    <label class="proxy-option">
                                        <input type="radio" name="proxyMethod" value="direct">
                                        <i class="fas fa-bolt"></i> Direct
                                    </label>
                                    <label class="proxy-option">
                                        <input type="radio" name="proxyMethod" value="corsproxy">
                                        <i class="fas fa-shield-alt"></i> CORS Proxy
                                    </label>
                                    <label class="proxy-option">
                                        <input type="radio" name="proxyMethod" value="allorigins">
                                        <i class="fas fa-server"></i> AllOrigins
                                    </label>
                                </div>
                                <p class="proxy-info">
                                    <strong>Tip:</strong> Use "Auto" for URLs with CORS issues.
                                    Direct only for public URLs that allow CORS.
                                </p>
                            </div>
                            
                            <button class="btn btn-full" id="convertWithPythonBtn" aria-label="Convert with Python">
                                <i class="fab fa-python"></i> Convert with Python
                            </button>
                            
                            <div class="format-info" id="formatInfo">
                                <div class="format-name" id="formatName">Format: M3U</div>
                                <div class="format-desc" id="formatDesc">Playlist format detected</div>
                            </div>
                            
                            <div class="stats-grid" id="statsGrid" style="display: none;">
                                <div class="stat-box">
                                    <div class="stat-value" id="statChannels">0</div>
                                    <div class="stat-label">Channels</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-value" id="statGroups">0</div>
                                    <div class="stat-label">Groups</div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-value" id="statLines">0</div>
                                    <div class="stat-label">Lines</div>
                                </div>
                            </div>
                            
                            <div class="url-examples">
                                <h4>Playlist Examples:</h4>
                                <ul class="url-list" role="list">
                                    <li role="button" tabindex="0" data-input='#EXTM3U
#KODIPROP:inputstream.adaptive.license_type=clearkey
#KODIPROP:inputstream.adaptive.license_key=c3004565365a42d08e3bde39a516d64e:dbfdc0967cfbbed01dba730c99d9c14a
#EXTVLCOPT:http-referrer=http://example.com/
#EXTVLCOPT:http-user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
#EXTINF:-1 tvg-id="IPTVTV.id" tvg-name="IPTVTV" tvg-logo="https://example.com/logo.jpg" group-title="IPTV",IPTV TV
https://http://example.com/out/v1/d6b026ad50f14b7f9af5ddd5450007d4/index.mpd'>M3U with license and EXTVLCOPT</li>
                                    <li role="button" tabindex="0" data-input='MOVIES,#genre#
John Wick,http://example.com/movie1.m3u8$license-key=abc123$license-type=clearkey$User-Agent=Mozilla/5.0$Referer=https://example.com/
Avengers,http://example.com/movie2.mp4$User-Agent=Mozilla/5.0$Referer=https://example.com/

SPORTS,#genre#
Premier League,http://example.com/sport1.mpd$license-key=def456$license-type=org.w3.clearkey$User-Agent=Mozilla/5.0
NBA Live,http://example.com/sport2.m3u8'>Example TXT with parameters (delimiter $)</li>
                                    <li role="button" tabindex="0" data-input='MOVIES,#genre#
John Wick,http://example.com/movie1.m3u8#license-key=abc123#license-type=clearkey#User-Agent=Mozilla/5.0#Referer=https://example.com/
Avengers,http://example.com/movie2.mp4#User-Agent=Mozilla/5.0#Referer=https://example.com/'>Example TXT with parameters (delimiter #)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <!-- File Mode -->
                    <div id="fileMode" class="upload-section" style="display: none;">
                        <h2><i class="fas fa-file-upload"></i> Upload File</h2>
                        
                        <div class="file-upload-area" id="dropArea" role="region" aria-label="File drop area">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <p id="dropAreaText">Drag & Drop Playlist File (Max 200MB)</p>
                            <p class="subtitle">or click to select file</p>
                            <input type="file" id="fileInput" class="file-input" accept=".m3u,.m3u8,.txt,.json,.xml,.csv,.ts,.mpd,.list,.log,.dat,text/*" aria-label="Select file">
                            <button class="btn btn-small" id="browseBtn" style="margin-top: 10px;" aria-label="Browse files">
                                <i class="fas fa-folder-open"></i> Select File
                            </button>
                        </div>
                        
                        <!-- Performance Warning for Large Files -->
                        <div class="performance-warning" id="performanceWarning" style="display: none;">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span id="performanceWarningText">Large file detected. Processing may take time.</span>
                        </div>
                        
                        <!-- Format Support Quick Info -->
                        <div class="format-support-info">
                            <i class="fas fa-file-code"></i>
                            <strong>Supported formats:</strong>
                            <ul>
                                <li><i class="fas fa-check"></i> M3U/M3U8 <span class="format-badge">.m3u .m3u8</span></li>
                                <li><i class="fas fa-check"></i> TXT <span class="format-badge">.txt .list</span></li>
                                <li><i class="fas fa-check"></i> JSON <span class="format-badge">.json</span></li>
                                <li><i class="fas fa-check"></i> XML <span class="format-badge">.xml</span></li>
                                <li><i class="fas fa-check"></i> CSV <span class="format-badge">.csv .dat</span></li>
                                <li><i class="fas fa-check"></i> Other text files <span class="format-badge">.ts .mpd .log</span></li>
                            </ul>
                        </div>
                        
                        <!-- File Info Display -->
                        <div class="file-info-display" id="fileInfoDisplay">
                            <div class="file-info-content">
                                <div class="file-icon">
                                    <i class="fas fa-file-alt"></i>
                                </div>
                                <div class="file-details">
                                    <div class="file-name" id="fileName">File name</div>
                                    <div class="file-meta" id="fileMeta">Size: 0 KB â€¢ Format: M3U</div>
                                </div>
                                <button class="file-remove-btn" id="removeFileBtn">
                                    <i class="fas fa-times"></i> Remove
                                </button>
                            </div>
                        </div>
                        
                        <div class="file-size-warning" id="fileSizeWarning">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span>File too large. Maximum 200MB per file.</span>
                            <div style="font-size: 0.8rem; margin-top: 5px;">
                                <i class="fas fa-lightbulb"></i> Tip: Split large playlists into multiple files
                            </div>
                        </div>
                        
                        <button class="btn btn-full" id="processFileBtn" disabled aria-label="Process file with Python">
                            <i class="fab fa-python"></i> Process File with Python
                        </button>
                        
                        <div class="format-info" id="fileFormatInfo">
                            <div class="format-name" id="fileFormatName">Format: M3U</div>
                            <div class="format-desc" id="fileFormatDesc">Playlist format detected</div>
                        </div>
                    </div>
                    
                    <!-- Manual Mode -->
                    <div id="manualMode" class="upload-section" style="display: none;">
                        <h2><i class="fas fa-keyboard"></i> Manual Input</h2>
                        
                        <div class="option-group">
                            <label for="manualInput">Paste M3U or TXT content:</label>
                            <textarea id="manualInput" placeholder="Paste M3U or TXT code here..." rows="12" aria-label="Manual input">#EXTM3U
#KODIPROP:inputstream.adaptive.license_type=clearkey
#KODIPROP:inputstream.adaptive.license_key=c3004565365a42d08e3bde39a516d64e:dbfdc0967cfbbed01dba730c99d9c14a
#EXTVLCOPT:http-referrer=http://example.com/
#EXTVLCOPT:http-user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
#EXTINF:-1 tvg-id="IPTVTV.id" tvg-name="IPTVTV" tvg-logo="https://example.com/logo.jpg" group-title="IPTV",IPTV TV
http://example.com/out/v1/d6b026ad50f14b7f9af5ddd5450007d4/index.mpd

#EXTINF:-1 tvg-id="" tvg-logo="https://imgur.com/QMB9sFW.png" group-title="Cignal", BBC Earth
http://example.com/bpk-tv/cg_bbcearth_hd1/default/index.mpd</textarea>
                        </div>
                        
                        <div class="example-txt-content" id="txtExample" style="display: none;">
                            <strong>Example TXT format with parameter delimiter #:</strong><br>
                            MOVIES,#genre#<br>
                            John Wick,http://example.com/movie1.m3u8#license-key=abc123#license-type=clearkey#User-Agent=Mozilla/5.0<br>
                            Avengers,http://example.com/movie2.mp4#User-Agent=Mozilla/5.0<br><br>
                            SPORTS,#genre#<br>
                            Premier League,http://example.com/sport1.mpd#license-key=def456#license-type=org.w3.clearkey#User-Agent=Mozilla/5.0
                        </div>
                        
                        <button class="btn btn-full" id="processManualBtn" aria-label="Process manual input with Python">
                            <i class="fab fa-python"></i> Process Manual with Python
                        </button>
                        
                        <div class="format-info" id="manualFormatInfo">
                            <div class="format-name" id="manualFormatName">Format: M3U</div>
                            <div class="format-desc" id="manualFormatDesc">Playlist format detected</div>
                        </div>
                    </div>
                    
                    <!-- Batch Mode -->
                    <div id="batchMode" class="upload-section" style="display: none;">
                        <h2><i class="fas fa-layer-group"></i> Batch Processing</h2>
                        
                        <div class="batch-processing" id="batchProcessing">
                            <div class="file-upload-area" id="batchDropArea" role="region" aria-label="Batch file drop area">
                                <i class="fas fa-cloud-upload-alt"></i>
                                <p id="batchDropAreaText">Drag & Drop Multiple Playlist Files (Max 200MB/file)</p>
                                <p class="subtitle">or click to select multiple files</p>
                                <input type="file" id="batchFileInput" class="file-input" accept=".m3u,.m3u8,.txt,.json,.xml,.csv,.ts,.mpd,.list,.log,.dat,text/*" multiple aria-label="Select multiple files">
                                <button class="btn btn-small" id="batchBrowseBtn" style="margin-top: 10px;" aria-label="Browse multiple files">
                                    <i class="fas fa-folder-open"></i> Select Multiple Files
                                </button>
                            </div>
                            
                            <!-- Performance Warning for Large Batch -->
                            <div class="performance-warning" id="batchPerformanceWarning" style="display: none;">
                                <i class="fas fa-exclamation-triangle"></i>
                                <span id="batchPerformanceWarningText">Batch total exceeds 300MB. Processing may be slow.</span>
                            </div>
                            
                            <div class="format-support-info">
                                <i class="fas fa-layer-group"></i>
                                <strong>Batch processing supports all formats:</strong>
                                <ul>
                                    <li><i class="fas fa-check"></i> M3U/M3U8 <span class="format-badge">.m3u .m3u8</span></li>
                                    <li><i class="fas fa-check"></i> TXT <span class="format-badge">.txt .list</span></li>
                                    <li><i class="fas fa-check"></i> JSON <span class="format-badge">.json</span></li>
                                    <li><i class="fas fa-check"></i> XML <span class="format-badge">.xml</span></li>
                                    <li><i class="fas fa-check"></i> CSV <span class="format-badge">.csv .dat</span></li>
                                    <li><i class="fas fa-check"></i> Others <span class="format-badge">.ts .mpd .log</span></li>
                                </ul>
                            </div>
                            
                            <div class="batch-empty" id="batchEmpty">
                                <i class="fas fa-folder-open" style="font-size: 2rem; margin-bottom: 10px;"></i>
                                <p>No files selected yet</p>
                                <p class="subtitle" style="font-size: 0.8rem;">Select multiple files using button above</p>
                            </div>
                            
                            <div class="batch-files" id="batchFiles" style="display: none;">
                                <!-- Batch files will be listed here -->
                            </div>
                            
                            <div class="batch-summary" id="batchSummary">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span>Total Files: <strong id="batchTotalFiles">0</strong></span>
                                    <span>Ready: <strong id="batchReadyFiles">0</strong></span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>Size: <strong id="batchTotalSize">0 KB</strong></span>
                                    <span>Status: <span id="batchOverallStatus">Ready</span></span>
                                </div>
                                <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 8px;">
                                    <i class="fas fa-info-circle"></i> Batch Limit: 200MB/file, 500MB total
                                </div>
                            </div>
                            
                            <div class="batch-progress" id="batchProgress" style="display: none;">
                                <div class="batch-progress-info">
                                    <span>Progress: <span id="batchProgressText">0/0</span></span>
                                    <span id="batchProgressPercent">0%</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="batchProgressBar"></div>
                                </div>
                            </div>
                            
                            <div class="batch-actions" id="batchActions" style="display: none;">
                                <button class="batch-clear-btn" id="batchClearBtn">
                                    <i class="fas fa-trash-alt"></i> Clear All
                                </button>
                            </div>
                            
                            <button class="btn btn-full" id="processBatchBtn" disabled aria-label="Process batch files with Python">
                                <i class="fab fa-python"></i> Process Batch with Python
                            </button>
                        </div>
                    </div>
                    
                    <!-- Loading Indicator -->
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <p id="loadingText">Checking Pyodide cache...</p>
                        <p style="font-size: 0.9rem; color: #94a3b8; margin-top: 10px;">
                            <i class="fas fa-info-circle"></i> 
                            <span id="loadingNote">Python runtime (~18MB) will be downloaded once only</span>
                        </p>
                    </div>
                    
                    <!-- Cache Status -->
                    <div class="cache-status" id="cacheStatus">
                        <i class="fas fa-database"></i>
                        <span id="cacheStatusText">Checking Pyodide cache...</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="cache-details">
                            <span>Cache: <strong id="loadedFromCache">Checking...</strong></span>
                            <span>Size: <strong id="cacheSize">0 MB</strong></span>
                            <span>Status: <strong id="cacheDetail">Loading...</strong></span>
                        </div>
                    </div>
                    
                    <!-- Error Details -->
                    <div class="error-details" id="errorDetails">
                        <i class="fas fa-exclamation-circle"></i>
                        <span id="errorDetailsText"></span>
                        <button class="retry-button" id="retryButton" style="display: none;">Retry</button>
                    </div>
                    
                    <!-- Cache Actions -->
                    <div class="cache-actions" id="cacheActions" style="display: none;">
                        <button class="cache-btn refresh" id="refreshCacheBtn" aria-label="Refresh cache">
                            <i class="fas fa-sync-alt"></i> Refresh Cache
                        </button>
                        <button class="cache-btn clear" id="clearCacheBtn" aria-label="Clear cache">
                            <i class="fas fa-trash-alt"></i> Clear Cache
                        </button>
                        <button class="cache-btn" id="checkCacheBtn" aria-label="Check cache status">
                            <i class="fas fa-search"></i> Check Cache
                        </button>
                    </div>
                    
                    <!-- Python Ready Info -->
                    <div class="python-runtime-info" id="pythonReady" style="display: none;">
                        <i class="fas fa-check-circle"></i>
                        <span id="pythonReadyText">Python runtime ready! Use conversion functions with Python in browser.</span>
                    </div>
                    
                    <!-- Python Console -->
                    <div class="python-console" id="pythonConsole" role="log" aria-label="Python console output">
                        <div class="log">>> Console output will appear here...</div>
                    </div>
                </div>
                
                <!-- Results Card -->
                <div class="card">
                    <h2><i class="fas fa-file-alt"></i> Conversion Result</h2>
                    
                    <div class="empty-state" id="emptyState">
                        <i class="fas fa-file-alt"></i>
                        <h3>No playlist converted yet</h3>
                        <p>Fetch URL, upload file, or manual input to see conversion result</p>
                    </div>
                    
                    <div class="result-area" id="resultArea" style="display: none;">
                        <textarea id="txtOutput" placeholder="Conversion result will appear here..." readonly aria-label="Conversion result"></textarea>
                        <div class="result-info">
                            <span>Channels: <span id="channelCount">0</span></span>
                            <span>Groups: <span id="groupCount">0</span></span>
                            <span>Status: <span id="status">Waiting...</span></span>
                        </div>
                        
                        <!-- EXPORT OPTIONS -->
                        <div class="export-options" id="exportOptions" style="display: none;">
                            <h4><i class="fas fa-download"></i> Export Options:</h4>
                            <div class="export-buttons">
                                <button class="export-btn" data-format="txt" aria-label="Export as TXT format" title="Export as TXT format">
                                    <i class="fas fa-file-alt"></i> TXT
                                </button>
                                <button class="export-btn" data-format="m3u" aria-label="Export as M3U format" title="Export as M3U (traditional format)">
                                    <i class="fas fa-file-code"></i> M3U
                                </button>
                                <button class="export-btn" data-format="m3u8" aria-label="Export as M3U8 (UTF-8 encoded)" title="Export as M3U8 (UTF-8 encoded for better compatibility)">
                                    <i class="fas fa-file-code"></i> M3U8
                                    <span style="font-size: 0.7rem; margin-left: 5px; color: #60a5fa;">UTF-8</span>
                                </button>
                                <button class="export-btn" data-format="json" aria-label="Export as JSON format" title="Export as JSON format">
                                    <i class="fas fa-file-code"></i> JSON
                                </button>
                            </div>
                            <div class="m3u8-info">
                                <i class="fas fa-info-circle"></i> 
                                <strong>M3U8</strong>: UTF-8 encoded, better for international characters and modern players
                            </div>
                        </div>
                        
                        <div class="action-buttons">
                            <button class="btn" id="downloadBtn" disabled aria-label="Download result">
                                <i class="fas fa-download"></i> Download Result
                            </button>
                            <button class="btn btn-secondary" id="clearBtn" aria-label="Clear result">
                                <i class="fas fa-trash-alt"></i> Clear
                            </button>
                            <button class="btn btn-secondary" id="testConnectionBtn" aria-label="Test connection">
                                <i class="fas fa-plug"></i> Test Connection
                            </button>
                            <button class="btn btn-secondary" id="copyBtn" disabled aria-label="Copy to clipboard">
                                <i class="fas fa-copy"></i> Copy
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        
        <footer class="footer" role="contentinfo">
            <p><i class="fab fa-python"></i> Powered by Pyodide â€¢ Python WebAssembly â€¢ M3U/TXT Converter</p>
            <p>Dual Direction: M3U â†” TXT â€¢ Dual Delimiter Support â€¢ Multi-Format Support â€¢ Support files up to 200MB</p>
            <p style="font-size: 0.8rem; margin-top: 10px; color: #64748b;">
                <i class="fas fa-database"></i> Cache Status: <span id="footerCacheStatus">Checking...</span> â€¢ 
                <i class="fas fa-history"></i> Last Cached: <span id="lastCachedDate">Never</span> â€¢
                <i class="fas fa-memory"></i> Memory: <span id="memoryUsage">0 MB</span> â€¢
                <i class="fas fa-file"></i> Max File: 200MB
            </p>
        </footer>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification" role="alert" aria-live="assertive">Python runtime successfully loaded!</div>

    <!-- Pyodide Runtime -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    
    <script>
        // ==================== JAVASCRIPT - DUAL DELIMITER SUPPORT ====================
        
        // Security and Performance Constants - UPDATED FOR 200MB SUPPORT
        const MAX_FILE_SIZE = 200 * 1024 * 1024; // Increased to 200MB
        const MAX_BATCH_TOTAL_SIZE = 500 * 1024 * 1024; // 500MB for batch total
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 1000; // 1 second
        const CACHE_EXPIRY_DAYS = 30;
        
        // Large file warning thresholds
        const LARGE_FILE_WARNING = 50 * 1024 * 1024; // 50MB
        const VERY_LARGE_FILE_WARNING = 100 * 1024 * 1024; // 100MB
        const BATCH_SIZE_WARNING = 300 * 1024 * 1024; // 300MB for batch total
        
        // Application State
        let pyodide = null;
        let isPythonLoaded = false;
        let convertedOutput = '';
        let currentMode = 'url';
        let conversionDirection = 'm3u2txt';
        let processingQueue = [];
        let isProcessing = false;
        let currentDownloadController = null;
        let batchFilesList = [];
        
        // Parameter Filter State
        let filterMode = 'keep'; // 'keep', 'remove', 'regex'
        let filterScope = 'all'; // 'all', 'selected', 'regex'
        let channelNamePattern = '';
        let activeFilters = [];
        let detectedParameters = [];
        
        // File Mode State
        let selectedFile = null; // Selected file for File Mode
        
        // Parameter Options State
        let parameterOptions = {
            predefined: [
                { id: 'user_agent', key: 'User-Agent', value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36', checked: false, isPredefined: true },
                { id: 'referer', key: 'Referer', value: 'https://example.com/', checked: false, isPredefined: true },
                { id: 'license_type', key: 'license-type', value: 'clearkey', checked: false, isPredefined: true },
                { id: 'license_key', key: 'license-key', value: 'your_license_key_here', checked: false, isPredefined: true },
                { id: 'origin', key: 'Origin', value: 'https://example.com', checked: false, isPredefined: true },
                { id: 'cookie', key: 'Cookie', value: 'session_id=abc123', checked: false, isPredefined: true },
                { id: 'timeout', key: 'timeout', value: '30', checked: false, isPredefined: true },
                { id: 'content_type', key: 'Content-Type', value: 'application/dash+xml', checked: false, isPredefined: true }
            ],
            custom: []
        };
        
        // PWA Variables
        let deferredPrompt = null;
        const pwaInstall = document.getElementById('pwaInstall');
        const installToast = document.getElementById('installToast');
        const installToastClose = document.getElementById('installToastClose');
        
        // DOM Elements
        const urlInput = document.getElementById('urlInput');
        const fetchBtn = document.getElementById('fetchBtn');
        const convertWithPythonBtn = document.getElementById('convertWithPythonBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const clearBtn = document.getElementById('clearBtn');
        const testConnectionBtn = document.getElementById('testConnectionBtn');
        const copyBtn = document.getElementById('copyBtn');
        const txtOutput = document.getElementById('txtOutput');
        const loadingEl = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const loadingNote = document.getElementById('loadingNote');
        const pythonConsole = document.getElementById('pythonConsole');
        const notification = document.getElementById('notification');
        const channelCount = document.getElementById('channelCount');
        const groupCount = document.getElementById('groupCount');
        const statusEl = document.getElementById('status');
        const proxySelect = document.getElementById('proxySelect');
        const emptyState = document.getElementById('emptyState');
        const resultArea = document.getElementById('resultArea');
        const statsGrid = document.getElementById('statsGrid');
        const statChannels = document.getElementById('statChannels');
        const statGroups = document.getElementById('statGroups');
        const statLines = document.getElementById('statLines');
        const pythonReady = document.getElementById('pythonReady');
        const pythonReadyText = document.getElementById('pythonReadyText');
        const conversionModeText = document.getElementById('conversionModeText');
        const dropAreaText = document.getElementById('dropAreaText');
        const txtExample = document.getElementById('txtExample');
        const firstTimeNote = document.getElementById('firstTimeNote');
        const offlineIndicator = document.getElementById('offlineIndicator');
        const connectionStatus = document.getElementById('connectionStatus');
        const errorDetails = document.getElementById('errorDetails');
        const errorDetailsText = document.getElementById('errorDetailsText');
        const retryButton = document.getElementById('retryButton');
        const exportOptions = document.getElementById('exportOptions');
        const exportButtons = document.querySelectorAll('.export-btn');
        const fileSizeWarning = document.getElementById('fileSizeWarning');
        const m3u8Info = document.querySelector('.m3u8-info');
        
        // New Elements for Large File Support
        const memoryMonitor = document.getElementById('memoryMonitor');
        const memoryPercent = document.getElementById('memoryPercent');
        const memoryUsedBar = document.getElementById('memoryUsedBar');
        const memoryUsed = document.getElementById('memoryUsed');
        const memoryAvailable = document.getElementById('memoryAvailable');
        const performanceWarning = document.getElementById('performanceWarning');
        const performanceWarningText = document.getElementById('performanceWarningText');
        const batchPerformanceWarning = document.getElementById('batchPerformanceWarning');
        const batchPerformanceWarningText = document.getElementById('batchPerformanceWarningText');
        
        // DELIMITER ELEMENTS - NEW
        const txtDelimiterSelect = document.getElementById('txtDelimiter');
        const paramDelimiterSelect = document.getElementById('paramDelimiter');
        const currentParamDelimiterSpan = document.getElementById('currentParamDelimiter');
        
        // Parameter options elements
        const parameterOptionsSection = document.getElementById('parameterOptions');
        const parameterSearch = document.getElementById('parameterSearch');
        const parameterList = document.getElementById('parameterList');
        const checkAllParamsBtn = document.getElementById('checkAllParamsBtn');
        const uncheckAllParamsBtn = document.getElementById('uncheckAllParamsBtn');
        const enableAllParamsBtn = document.getElementById('enableAllParamsBtn');
        const disableAllParamsBtn = document.getElementById('disableAllParamsBtn');
        const newParamKey = document.getElementById('newParamKey');
        const newParamValue = document.getElementById('newParamValue');
        const addNewParamBtn = document.getElementById('addNewParamBtn');
        const templateButtons = document.getElementById('templateButtons');
        
        // Parameter Filter elements
        const parameterFilterOptions = document.getElementById('parameterFilterOptions');
        const filterOptionsContent = document.getElementById('filterOptionsContent');
        const toggleFilterBtn = document.getElementById('toggleFilterBtn');
        const filterModeBtns = document.querySelectorAll('.mode-btn-small');
        const parameterFilterList = document.getElementById('parameterFilterList');
        const filterOptionsKeep = document.getElementById('filterOptionsKeep');
        const filterOptionsRegex = document.getElementById('filterOptionsRegex');
        const regexPattern = document.getElementById('regexPattern');
        const testRegexBtn = document.getElementById('testRegexBtn');
        const regexTestResult = document.getElementById('regexTestResult');
        const regexResultText = document.getElementById('regexResultText');
        const scopeOptions = document.querySelectorAll('input[name="filterScope"]');
        const channelRegexInput = document.getElementById('channelRegexInput');
        const channelNamePatternInput = document.getElementById('channelNamePattern');
        const analyzeParamsBtn = document.getElementById('analyzeParamsBtn');
        const applyFilterBtn = document.getElementById('applyFilterBtn');
        const resetFilterBtn = document.getElementById('resetFilterBtn');
        const filterStatus = document.getElementById('filterStatus');
        
        // Copy fallback elements
        const copyFallback = document.getElementById('copyFallback');
        const copyFallbackTextarea = document.getElementById('copyFallbackTextarea');
        const copySelectAllBtn = document.getElementById('copySelectAllBtn');
        const copyCloseBtn = document.getElementById('copyCloseBtn');
        
        // Batch Mode Elements
        const batchProcessing = document.getElementById('batchProcessing');
        const batchEmpty = document.getElementById('batchEmpty');
        const batchFiles = document.getElementById('batchFiles');
        const batchFileInput = document.getElementById('batchFileInput');
        const batchBrowseBtn = document.getElementById('batchBrowseBtn');
        const processBatchBtn = document.getElementById('processBatchBtn');
        const batchSummary = document.getElementById('batchSummary');
        const batchTotalFiles = document.getElementById('batchTotalFiles');
        const batchReadyFiles = document.getElementById('batchReadyFiles');
        const batchTotalSize = document.getElementById('batchTotalSize');
        const batchOverallStatus = document.getElementById('batchOverallStatus');
        const batchProgress = document.getElementById('batchProgress');
        const batchProgressText = document.getElementById('batchProgressText');
        const batchProgressPercent = document.getElementById('batchProgressPercent');
        const batchProgressBar = document.getElementById('batchProgressBar');
        const batchActions = document.getElementById('batchActions');
        const batchClearBtn = document.getElementById('batchClearBtn');
        
        // Direct download elements
        const directDownloadBtn = document.getElementById('directDownloadBtn');
        const directDownloadInfo = document.getElementById('directDownloadInfo');
        const cancelDownloadBtn = document.getElementById('cancelDownloadBtn');
        const downloadProgress = document.getElementById('downloadProgress');
        const downloadStatus = document.getElementById('downloadStatus');
        
        // Cache elements
        const cacheStatus = document.getElementById('cacheStatus');
        const cacheStatusText = document.getElementById('cacheStatusText');
        const loadedFromCache = document.getElementById('loadedFromCache');
        const cacheSize = document.getElementById('cacheSize');
        const progressFill = document.getElementById('progressFill');
        const cacheDetail = document.getElementById('cacheDetail');
        const cacheActions = document.getElementById('cacheActions');
        const refreshCacheBtn = document.getElementById('refreshCacheBtn');
        const clearCacheBtn = document.getElementById('clearCacheBtn');
        const checkCacheBtn = document.getElementById('checkCacheBtn');
        const footerCacheStatus = document.getElementById('footerCacheStatus');
        const lastCachedDate = document.getElementById('lastCachedDate');
        const memoryUsage = document.getElementById('memoryUsage');
        
        // Mode elements
        const modeBtns = document.querySelectorAll('.mode-btn');
        const directionBtns = document.querySelectorAll('.direction-btn');
        const urlMode = document.getElementById('urlMode');
        const fileMode = document.getElementById('fileMode');
        const manualMode = document.getElementById('manualMode');
        const batchMode = document.getElementById('batchMode');
        const fileInput = document.getElementById('fileInput');
        const browseBtn = document.getElementById('browseBtn');
        const dropArea = document.getElementById('dropArea');
        const processFileBtn = document.getElementById('processFileBtn');
        const processManualBtn = document.getElementById('processManualBtn');
        const manualInput = document.getElementById('manualInput');
        const ariaLive = document.getElementById('aria-live');
        
        // File Mode Elements
        const fileInfoDisplay = document.getElementById('fileInfoDisplay');
        const fileNameElement = document.getElementById('fileName');
        const fileMetaElement = document.getElementById('fileMeta');
        const removeFileBtn = document.getElementById('removeFileBtn');
        
        // ========== UPDATED HELPER FUNCTIONS FOR 200MB SUPPORT ==========
        
        // Function to update memory monitor
        function updateMemoryMonitor() {
            if (window.performance && window.performance.memory) {
                const memory = window.performance.memory;
                const usedMB = (memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                const totalMB = (memory.totalJSHeapSize / 1024 / 1024).toFixed(1);
                const limitMB = (memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1);
                const usedPercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
                
                memoryPercent.textContent = `${usedPercent.toFixed(1)}%`;
                memoryUsedBar.style.width = `${usedPercent}%`;
                memoryUsed.textContent = `${usedMB} MB`;
                memoryAvailable.textContent = `${(limitMB - usedMB).toFixed(1)} MB`;
                
                // Update global memory usage
                memoryUsage.textContent = `${usedMB} MB`;
                
                // Change color based on memory usage
                if (usedPercent > 80) {
                    memoryUsedBar.style.background = 'linear-gradient(90deg, #ef4444, #f87171)';
                    memoryMonitor.style.borderColor = '#ef4444';
                } else if (usedPercent > 60) {
                    memoryUsedBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)';
                    memoryMonitor.style.borderColor = '#f59e0b';
                } else {
                    memoryUsedBar.style.background = 'linear-gradient(90deg, #10b981, #3b82f6)';
                    memoryMonitor.style.borderColor = '#3b82f6';
                }
                
                return {
                    usedPercent,
                    usedMB: parseFloat(usedMB),
                    totalMB: parseFloat(totalMB),
                    limitMB: parseFloat(limitMB)
                };
            }
            return null;
        }
        
        // Enhanced file size validation with memory check
        function validateFileSize(file, isBatch = false) {
            const fileSize = file.size;
            const maxSize = MAX_FILE_SIZE;
            
            // Update memory monitor
            const memoryInfo = updateMemoryMonitor();
            
            // Check memory before validating large files
            if (fileSize > 50 * 1024 * 1024) { // If file > 50MB
                if (memoryInfo) {
                    if (memoryInfo.usedPercent > 85) {
                        return {
                            valid: false,
                            message: `Browser memory almost full (${memoryInfo.usedPercent.toFixed(1)}%). Cannot process large file. Try closing other tabs.`
                        };
                    }
                    
                    // Estimate memory needed (file size * 2 for processing)
                    const estimatedMemoryNeeded = (fileSize / 1024 / 1024) * 2;
                    const availableMemory = memoryInfo.limitMB - memoryInfo.usedMB;
                    
                    if (estimatedMemoryNeeded > availableMemory * 0.8) {
                        return {
                            valid: false,
                            message: `File too large for available memory. Estimated needed: ${estimatedMemoryNeeded.toFixed(1)}MB, available: ${availableMemory.toFixed(1)}MB.`
                        };
                    }
                }
            }
            
            if (fileSize > maxSize) {
                return {
                    valid: false,
                    message: `File "${file.name}" too large (${formatFileSize(fileSize)}). Maximum ${formatFileSize(maxSize)}.`
                };
            }
            
            // Check for batch total size
            if (isBatch) {
                const totalBatchSize = batchFilesList.reduce((sum, f) => sum + f.size, 0) + fileSize;
                if (totalBatchSize > MAX_BATCH_TOTAL_SIZE) {
                    return {
                        valid: false,
                        message: `Batch total will exceed ${formatFileSize(MAX_BATCH_TOTAL_SIZE)}. Remove some files first.`
                    };
                }
                
                // Show batch performance warning
                if (totalBatchSize > BATCH_SIZE_WARNING) {
                    batchPerformanceWarning.style.display = 'flex';
                    batchPerformanceWarningText.textContent = `Batch total ${formatFileSize(totalBatchSize)}. Processing may be slow.`;
                } else {
                    batchPerformanceWarning.style.display = 'none';
                }
            }
            
            // Show file size warnings
            if (fileSize > VERY_LARGE_FILE_WARNING) {
                performanceWarning.style.display = 'flex';
                performanceWarningText.textContent = `Very large file (${formatFileSize(fileSize)}). Processing may take a long time.`;
            } else if (fileSize > LARGE_FILE_WARNING) {
                performanceWarning.style.display = 'flex';
                performanceWarningText.textContent = `Large file detected (${formatFileSize(fileSize)}). Please wait.`;
            } else {
                performanceWarning.style.display = 'none';
            }
            
            return { valid: true };
        }
        
        // Optimized file reading for large files
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                // Show progress for large files
                if (file.size > 50 * 1024 * 1024) {
                    logToConsole(`Reading large file: ${formatFileSize(file.size)}...`, 'info');
                    showNotification(`Reading large file (${formatFileSize(file.size)})...`, 'info');
                }
                
                reader.onloadstart = () => {
                    if (file.size > 100 * 1024 * 1024) {
                        statusEl.textContent = 'Reading large file...';
                    }
                };
                
                reader.onload = (e) => {
                    let content = e.target.result;
                    
                    // Check for encoding issues (only for text files)
                    if (file.type.startsWith('text/') || file.name.match(/\.(txt|m3u|m3u8|json|xml|csv)$/i)) {
                        if (content.includes('ï¿½') || content.includes('\ufffd')) {
                            logToConsole('UTF-8 decoding issue, trying alternative encodings...', 'warning');
                            
                            // Try alternative encoding
                            const reader2 = new FileReader();
                            reader2.onload = (e2) => {
                                const arrayBuffer = e2.target.result;
                                const decoders = [
                                    { name: 'UTF-8', decoder: new TextDecoder('utf-8') },
                                    { name: 'Latin-1', decoder: new TextDecoder('iso-8859-1') },
                                    { name: 'Windows-1252', decoder: new TextDecoder('windows-1252') },
                                    { name: 'UTF-16', decoder: new TextDecoder('utf-16') }
                                ];
                                
                                for (const { name, decoder } of decoders) {
                                    try {
                                        const decoded = decoder.decode(arrayBuffer);
                                        if (!decoded.includes('ï¿½') && !decoded.includes('\ufffd')) {
                                            logToConsole(`File successfully decoded as ${name}`, 'success');
                                            resolve(decoded);
                                            return;
                                        }
                                    } catch (e) {
                                        continue;
                                    }
                                }
                                
                                // Fallback to original content
                                logToConsole('Using original content despite encoding issues', 'warning');
                                resolve(content);
                            };
                            reader2.readAsArrayBuffer(file);
                            return;
                        }
                    }
                    
                    resolve(content);
                };
                
                reader.onerror = (e) => {
                    console.error('File reading error:', e.target.error);
                    reject(new Error(`Failed to read file: ${e.target.error.message}`));
                };
                
                // For very large files, use different approach
                if (file.size > 100 * 1024 * 1024) {
                    // Use ArrayBuffer for better performance with large files
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file, 'UTF-8');
                }
            });
        }
        
        // Optimized content processing for large files
        function processLargeContent(content, filename) {
            return new Promise((resolve) => {
                // Split content into chunks for large processing
                const lines = content.split('\n');
                const chunkSize = 10000; // Process 10k lines at a time
                
                if (lines.length > 50000) {
                    logToConsole(`Processing large file: ${lines.length.toLocaleString()} lines`, 'info');
                    showNotification(`Processing ${lines.length.toLocaleString()} lines...`, 'info');
                    
                    // Process in chunks to avoid blocking
                    setTimeout(() => {
                        let processed = 0;
                        const totalChunks = Math.ceil(lines.length / chunkSize);
                        
                        const processChunk = (chunkIndex) => {
                            const start = chunkIndex * chunkSize;
                            const end = Math.min(start + chunkSize, lines.length);
                            const chunk = lines.slice(start, end);
                            
                            // Process chunk here
                            processed += chunk.length;
                            
                            // Update progress
                            if (chunkIndex % 10 === 0 || chunkIndex === totalChunks - 1) {
                                const progress = Math.round((processed / lines.length) * 100);
                                logToConsole(`Processing: ${progress}% (${processed.toLocaleString()}/${lines.length.toLocaleString()} lines)`, 'info');
                            }
                            
                            // Schedule next chunk
                            if (chunkIndex < totalChunks - 1) {
                                setTimeout(() => processChunk(chunkIndex + 1), 10);
                            } else {
                                resolve(content);
                            }
                        };
                        
                        // Start processing
                        processChunk(0);
                    }, 100);
                } else {
                    resolve(content);
                }
            });
        }
        
        // ========== CORE FUNCTIONS (SAME AS BEFORE BUT OPTIMIZED) ==========
        
        // Security: Escape HTML to prevent XSS
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        // Security: URL validation
        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return url.protocol === 'http:' || url.protocol === 'https:';
            } catch (_) {
                return false;
            }
        }
        
        // Function to get file extension
        function getFileExtension(filename) {
            return filename.split('.').pop().toLowerCase();
        }
        
        // Function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Content validation for all formats with optimization for large files
        function validateContent(content, filename = '') {
            if (!content || typeof content !== 'string') {
                throw new Error('Invalid content');
            }
            
            if (content.length > MAX_FILE_SIZE) {
                throw new Error(`Content too large (${(content.length/1024/1024).toFixed(2)}MB). Maximum ${(MAX_FILE_SIZE/1024/1024).toFixed(0)}MB.`);
            }
            
            // For very large files, perform simple validation
            if (content.length > 100 * 1024 * 1024) { // 100MB
                // Check only first few lines
                const firstLines = content.substring(0, 10000);
                if (!firstLines.includes('http://') && !firstLines.includes('https://')) {
                    throw new Error('Playlist format not recognized. Make sure it contains streaming URLs.');
                }
                return 'large_text';
            }
            
            const firstLines = content.split('\n').slice(0, 20).join('\n');
            const contentLower = content.toLowerCase();
            
            // Detection based on extension
            const ext = getFileExtension(filename);
            const extMap = {
                'm3u': 'm3u',
                'm3u8': 'm3u',
                'txt': 'txt',
                'list': 'txt',
                'json': 'json',
                'xml': 'xml',
                'csv': 'csv',
                'ts': 'ts',
                'mpd': 'mpd',
                'log': 'log',
                'dat': 'dat'
            };
            
            if (extMap[ext]) {
                return extMap[ext];
            }
            
            // Detection based on content
            if (content.includes('#EXTM3U') || content.includes('#EXTINF:')) {
                return 'm3u';
            }
            
            if (content.includes('#genre#') || (content.includes(',') && content.includes('http'))) {
                return 'txt';
            }
            
            try {
                JSON.parse(content);
                return 'json';
            } catch (e) {
                // Not JSON
            }
            
            if (content.trim().startsWith('<?xml') || content.includes('<?xml')) {
                return 'xml';
            }
            
            if (content.includes(',') && content.split('\n').every(line => line.includes(',') || line.trim() === '')) {
                return 'csv';
            }
            
            // Default: try to parse as text playlist
            return 'txt';
        }
        
        // ========== DUAL DELIMITER FUNCTIONS ==========
        
        // Function to get TXT delimiter (channel-URL)
        function getTxtDelimiter() {
            const txtDelimiter = txtDelimiterSelect.value;
            // Handle tab delimiter
            return txtDelimiter === 'tab' ? '\t' : txtDelimiter;
        }
        
        // Function to get parameter delimiter (within URL)
        function getParamDelimiter() {
            return paramDelimiterSelect.value;
        }
        
        // Update current param delimiter display
        function updateParamDelimiterDisplay() {
            currentParamDelimiterSpan.textContent = getParamDelimiter();
        }
        
        // Function to escape delimiter for regex
        function escapeDelimiterForRegex(delimiter) {
            if (delimiter === '#') {
                return '\\#'; // Escape hash for regex
            } else if (delimiter === '$') {
                return '\\$';
            } else if (delimiter === '|') {
                return '\\|';
            } else if (delimiter === '&') {
                return '&';
            } else {
                return delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
        }
        
        // Function to parse URL with parameters using selected delimiter
        function parseUrlWithParams(url, paramDelimiter) {
            if (!url.includes(paramDelimiter)) {
                return { url: url, params: {} };
            }
            
            // Handle special delimiters
            if (paramDelimiter === '#') {
                const hashIndex = url.indexOf('#');
                if (hashIndex === -1) {
                    return { url: url, params: {} };
                }
                
                const baseUrl = url.substring(0, hashIndex);
                const paramString = url.substring(hashIndex + 1);
                
                const params = {};
                const paramParts = paramString.split('#');
                
                for (const part of paramParts) {
                    if (part.includes('=')) {
                        const [key, ...valueParts] = part.split('=');
                        const value = valueParts.join('=');
                        params[key.trim()] = value.trim();
                    }
                }
                
                return { url: baseUrl, params };
            } else {
                const parts = url.split(paramDelimiter);
                const baseUrl = parts[0];
                const params = {};
                
                for (let i = 1; i < parts.length; i++) {
                    const paramPart = parts[i];
                    if (paramPart.includes('=')) {
                        const [key, ...valueParts] = paramPart.split('=');
                        const value = valueParts.join('=');
                        params[key.trim()] = value.trim();
                    }
                }
                
                return { url: baseUrl, params };
            }
        }
        
        // Save delimiter settings to localStorage
        function saveDelimiterSettings() {
            const settings = {
                txtDelimiter: txtDelimiterSelect.value,
                paramDelimiter: paramDelimiterSelect.value,
                mode: currentMode,
                direction: conversionDirection
            };
            localStorage.setItem('m3u_delimiter_settings', JSON.stringify(settings));
        }
        
        // Load delimiter settings from localStorage
        function loadDelimiterSettings() {
            try {
                const saved = localStorage.getItem('m3u_delimiter_settings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    
                    if (settings.txtDelimiter) {
                        txtDelimiterSelect.value = settings.txtDelimiter;
                    }
                    
                    if (settings.paramDelimiter) {
                        paramDelimiterSelect.value = settings.paramDelimiter;
                        updateParamDelimiterDisplay();
                    }
                    
                    logToConsole('Delimiter settings loaded from localStorage', 'info');
                }
            } catch (e) {
                console.error('Error loading delimiter settings:', e);
            }
        }
        
        // Function to copy text to clipboard
        async function copyToClipboard(text) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                } else {
                    return copyToClipboardFallback(text);
                }
            } catch (error) {
                console.error('Copy error:', error);
                return copyToClipboardFallback(text);
            }
        }
        
        // Fallback method for copy
        function copyToClipboardFallback(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-999999px';
            textarea.style.top = '-999999px';
            document.body.appendChild(textarea);
            
            try {
                textarea.select();
                textarea.setSelectionRange(0, 99999);
                
                const successful = document.execCommand('copy');
                textarea.remove();
                
                return successful;
            } catch (error) {
                console.error('Fallback copy error:', error);
                textarea.remove();
                
                showCopyFallback(text);
                return false;
            }
        }
        
        // Show fallback modal for manual copy
        function showCopyFallback(text) {
            copyFallbackTextarea.value = text;
            copyFallback.style.display = 'flex';
        }
        
        // Log to Python console with sanitization
        function logToConsole(message, type = 'log') {
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `>> ${escapeHtml(message.toString())}`;
            pythonConsole.appendChild(div);
            pythonConsole.scrollTop = pythonConsole.scrollHeight;
            
            if (pythonConsole.children.length > 100) {
                pythonConsole.removeChild(pythonConsole.firstChild);
            }
        }
        
        // Clear console
        function clearConsole() {
            pythonConsole.innerHTML = '<div class="log">>> Console cleared</div>';
        }
        
        // Update ARIA live region for screen readers
        function updateAriaLive(message) {
            ariaLive.textContent = message;
            setTimeout(() => {
                ariaLive.textContent = '';
            }, 1000);
        }
        
        // Update progress bar
        function updateProgress(current, total, message) {
            const progress = Math.round((current / total) * 100);
            progressFill.style.width = `${progress}%`;
            cacheStatusText.textContent = message;
            
            if (current % 10 === 0 || current === total) {
                logToConsole(`${message} - ${progress}%`, 'info');
            }
        }
        
        // Retry mechanism with exponential backoff
        async function retryOperation(operation, maxRetries = MAX_RETRIES) {
            let lastError;
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await operation();
                } catch (error) {
                    lastError = error;
                    logToConsole(`Attempt ${i + 1} failed: ${error.message}`, 'warning');
                    
                    if (i < maxRetries - 1) {
                        const delay = RETRY_DELAY * Math.pow(2, i);
                        logToConsole(`Retrying in ${delay}ms...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            throw lastError;
        }
        
        // Setup cache expiration
        function setupCacheExpiration() {
            const lastCleanup = localStorage.getItem('last_cache_cleanup');
            const now = new Date().getTime();
            
            if (!lastCleanup || (now - lastCleanup) > (CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)) {
                logToConsole('Cleaning up expired cache...', 'info');
                clearPyodideCache();
                localStorage.setItem('last_cache_cleanup', now);
            }
        }
        
        // Function to estimate cache size
        async function estimateCacheSize() {
            if (!('indexedDB' in window)) return '0 MB';
            
            try {
                const db = await new Promise((resolve, reject) => {
                    const request = indexedDB.open('pyodide', 1);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                if (!db.objectStoreNames.contains('pyodide')) return '0 MB';
                
                return new Promise((resolve) => {
                    let totalSize = 0;
                    const transaction = db.transaction(['pyodide'], 'readonly');
                    const store = transaction.objectStore('pyodide');
                    const request = store.openCursor();
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            if (cursor.value && cursor.value.size) {
                                totalSize += cursor.value.size;
                            } else if (cursor.value instanceof ArrayBuffer) {
                                totalSize += cursor.value.byteLength;
                            }
                            cursor.continue();
                        } else {
                            const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
                            resolve(`${sizeMB} MB`);
                        }
                    };
                    
                    request.onerror = () => resolve('0 MB');
                });
            } catch (e) {
                return '0 MB';
            }
        }
        
        // Update connection status
        function updateConnectionStatus() {
            const isOnline = navigator.onLine;
            connectionStatus.textContent = isOnline ? 'Online' : 'Offline';
            
            if (isOnline) {
                offlineIndicator.className = 'offline-indicator online';
                offlineIndicator.style.display = 'flex';
                setTimeout(() => {
                    offlineIndicator.style.display = 'none';
                }, 3000);
            } else {
                offlineIndicator.className = 'offline-indicator offline';
                offlineIndicator.style.display = 'flex';
                
                if (localStorage.getItem('pyodide_cached') === 'true') {
                    logToConsole('You are offline, but Pyodide is cached. App still works!', 'success');
                } else {
                    logToConsole('You are offline and Pyodide not cached. Some features may not work.', 'warning');
                }
            }
            
            updateAriaLive(isOnline ? 'Connection online' : 'Connection offline');
        }
        
        // Clear Pyodide cache
        async function clearPyodideCache() {
            try {
                if ('indexedDB' in window) {
                    const request = indexedDB.deleteDatabase('pyodide');
                    
                    request.onsuccess = () => {
                        localStorage.removeItem('pyodide_cached');
                        localStorage.removeItem('pyodide_cached_date');
                        localStorage.removeItem('last_cache_cleanup');
                        
                        cacheSize.textContent = '0 MB';
                        loadedFromCache.textContent = 'No';
                        footerCacheStatus.textContent = 'Cleared';
                        lastCachedDate.textContent = 'Never';
                        
                        logToConsole('Pyodide cache cleared successfully!', 'success');
                        showNotification('Pyodide cache cleared successfully', 'info');
                        updateAriaLive('Pyodide cache cleared successfully');
                        
                        setTimeout(() => {
                            if (confirm('Cache cleared successfully. Reload page to download Pyodide again?')) {
                                location.reload();
                            }
                        }, 1000);
                    };
                    
                    request.onerror = (e) => {
                        logToConsole('Error clearing cache: ' + e, 'error');
                        showNotification('Failed to clear cache', 'error');
                    };
                } else {
                    showNotification('Browser does not support IndexedDB', 'error');
                }
            } catch (error) {
                logToConsole('Error clearing cache: ' + error.message, 'error');
                showNotification('Error: ' + error.message, 'error');
            }
        }
        
        // Check cache status
        async function checkCacheStatus() {
            try {
                const size = await estimateCacheSize();
                const isCached = localStorage.getItem('pyodide_cached') === 'true';
                const cachedDate = localStorage.getItem('pyodide_cached_date');
                
                let message = `Cache Status: ${isCached ? 'Cached' : 'Not Cached'}\n`;
                message += `Cache Size: ${size}\n`;
                
                if (cachedDate) {
                    const date = new Date(cachedDate);
                    message += `Last Cached: ${date.toLocaleString('en-US')}`;
                }
                
                logToConsole(message, 'info');
                showNotification(`Cache: ${size}`, 'info');
                
                cacheSize.textContent = size;
                loadedFromCache.textContent = isCached ? 'Yes' : 'No';
                footerCacheStatus.textContent = isCached ? 'Cached' : 'Not cached';
                
                if (cachedDate) {
                    lastCachedDate.textContent = new Date(cachedDate).toLocaleDateString('en-US');
                }
                
                updateAriaLive(`Cache status: ${size}, ${isCached ? 'cached' : 'not cached'}`);
                
            } catch (error) {
                logToConsole('Error checking cache: ' + error.message, 'error');
            }
        }
        
        // Get selected proxy method
        function getSelectedProxyMethod() {
            const selected = document.querySelector('input[name="proxyMethod"]:checked');
            return selected ? selected.value : 'auto';
        }
        
        // ========== PARAMETER OPTIONS FUNCTIONS ==========
        
        // Initialize parameter options UI
        function initializeParameterOptions() {
            updateParameterList();
            initializeTemplateButtons();
            loadParameterOptions();
        }
        
        // Update parameter list with editable fields
        function updateParameterList() {
            parameterList.innerHTML = '';
            
            const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
            
            if (allParameters.length === 0) {
                parameterList.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #94a3b8; font-style: italic;">
                        <i class="fas fa-plus-circle" style="font-size: 2rem; margin-bottom: 10px;"></i>
                        <p>No parameters yet. Add new parameters using form below.</p>
                    </div>
                `;
                return;
            }
            
            const searchTerm = parameterSearch.value.toLowerCase();
            const filteredParams = searchTerm ? 
                allParameters.filter(param => 
                    param.key.toLowerCase().includes(searchTerm) || 
                    param.value.toLowerCase().includes(searchTerm)
                ) : allParameters;
            
            if (filteredParams.length === 0) {
                parameterList.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #94a3b8; font-style: italic;">
                        <i class="fas fa-search"></i> No parameters found matching search
                    </div>
                `;
                return;
            }
            
            filteredParams.forEach(param => {
                const isPredefined = param.isPredefined || false;
                const paramId = param.id || param.key.replace(/\s+/g, '_').toLowerCase();
                
                const paramItem = document.createElement('div');
                paramItem.className = 'parameter-item';
                paramItem.dataset.paramId = paramId;
                
                paramItem.innerHTML = `
                    <input type="checkbox" class="parameter-item-checkbox" 
                           id="param_${paramId}"
                           ${param.checked ? 'checked' : ''}
                           ${isPredefined ? 'data-predefined="true"' : ''}>
                    
                    <div class="parameter-item-inputs">
                        <input type="text" class="parameter-key-input" 
                               value="${escapeHtml(param.key)}"
                               placeholder="Parameter key"
                               ${param.checked ? '' : 'disabled'}
                               ${isPredefined ? 'data-predefined="true"' : ''}>
                        
                        <input type="text" class="parameter-value-input" 
                               value="${escapeHtml(param.value)}"
                               placeholder="Parameter value"
                               ${param.checked ? '' : 'disabled'}
                               ${isPredefined ? 'data-predefined="true"' : ''}>
                    </div>
                    
                    <div class="parameter-item-actions">
                        <button type="button" class="parameter-remove-btn" 
                                title="Remove parameter"
                                ${isPredefined ? 'disabled' : ''}>
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                parameterList.appendChild(paramItem);
                
                // Add event listeners
                const checkbox = paramItem.querySelector('.parameter-item-checkbox');
                const keyInput = paramItem.querySelector('.parameter-key-input');
                const valueInput = paramItem.querySelector('.parameter-value-input');
                const removeBtn = paramItem.querySelector('.parameter-remove-btn');
                
                checkbox.addEventListener('change', (e) => {
                    const checked = e.target.checked;
                    keyInput.disabled = !checked;
                    valueInput.disabled = !checked;
                    
                    updateParameterState(paramId, { checked });
                    saveParameterOptions();
                    logToConsole(`Parameter "${keyInput.value}" ${checked ? 'enabled' : 'disabled'}`, 'info');
                });
                
                keyInput.addEventListener('input', (e) => {
                    updateParameterState(paramId, { key: e.target.value });
                    saveParameterOptions();
                });
                
                keyInput.addEventListener('blur', (e) => {
                    if (!e.target.value.trim()) {
                        e.target.value = param.key;
                        logToConsole('Parameter key cannot be empty', 'warning');
                    }
                    saveParameterOptions();
                });
                
                valueInput.addEventListener('input', (e) => {
                    updateParameterState(paramId, { value: e.target.value });
                    saveParameterOptions();
                });
                
                valueInput.addEventListener('blur', (e) => {
                    if (!e.target.value.trim()) {
                        e.target.value = param.value;
                        logToConsole('Parameter value cannot be empty', 'warning');
                    }
                    saveParameterOptions();
                });
                
                if (!isPredefined) {
                    removeBtn.addEventListener('click', () => {
                        if (confirm(`Remove parameter "${keyInput.value}"?`)) {
                            removeParameter(paramId);
                        }
                    });
                }
            });
        }
        
        // Update parameter state based on ID
        function updateParameterState(paramId, updates) {
            let paramIndex = parameterOptions.predefined.findIndex(p => 
                p.id === paramId || p.key.replace(/\s+/g, '_').toLowerCase() === paramId
            );
            
            if (paramIndex !== -1) {
                parameterOptions.predefined[paramIndex] = {
                    ...parameterOptions.predefined[paramIndex],
                    ...updates
                };
                return;
            }
            
            paramIndex = parameterOptions.custom.findIndex(p => 
                p.id === paramId || p.key.replace(/\s+/g, '_').toLowerCase() === paramId
            );
            
            if (paramIndex !== -1) {
                parameterOptions.custom[paramIndex] = {
                    ...parameterOptions.custom[paramIndex],
                    ...updates
                };
                return;
            }
            
            if (updates.key && updates.value !== undefined) {
                const newParam = {
                    id: paramId,
                    key: updates.key,
                    value: updates.value || '',
                    checked: updates.checked || false,
                    isPredefined: false
                };
                parameterOptions.custom.push(newParam);
            }
        }
        
        // Remove parameter based on ID
        function removeParameter(paramId) {
            const paramIndex = parameterOptions.custom.findIndex(p => 
                p.id === paramId || p.key.replace(/\s+/g, '_').toLowerCase() === paramId
            );
            
            if (paramIndex !== -1) {
                const removedParam = parameterOptions.custom.splice(paramIndex, 1)[0];
                logToConsole(`Parameter "${removedParam.key}" removed`, 'info');
                showNotification(`Parameter "${removedParam.key}" removed`, 'info');
                updateParameterList();
                saveParameterOptions();
            }
        }
        
        // Add new parameter
        function addNewParameter() {
            const key = newParamKey.value.trim();
            const value = newParamValue.value.trim();
            
            if (!key) {
                showNotification('Enter parameter key first', 'error');
                newParamKey.focus();
                return;
            }
            
            if (!value) {
                showNotification('Enter parameter value first', 'error');
                newParamValue.focus();
                return;
            }
            
            const existingParam = [...parameterOptions.predefined, ...parameterOptions.custom]
                .find(p => p.key.toLowerCase() === key.toLowerCase());
            
            if (existingParam) {
                showNotification(`Parameter "${key}" already exists`, 'warning');
                updateParameterState(existingParam.id || existingParam.key, { value, checked: true });
            } else {
                const newParam = {
                    id: key.replace(/\s+/g, '_').toLowerCase(),
                    key,
                    value,
                    checked: true,
                    isPredefined: false
                };
                parameterOptions.custom.push(newParam);
                
                logToConsole(`New parameter added: "${key}" = "${value}"`, 'success');
                showNotification(`Parameter "${key}" added`, 'success');
            }
            
            newParamKey.value = '';
            newParamValue.value = '';
            
            updateParameterList();
            saveParameterOptions();
            
            newParamKey.focus();
        }
        
        // Initialize template buttons
        function initializeTemplateButtons() {
            templateButtons.innerHTML = '';
            
            const templates = [
                { name: 'IPTV', params: [
                    { key: 'User-Agent', value: 'VLC/3.0.18 LibVLC/3.0.18' },
                    { key: 'Referer', value: 'https://iptv.example.com/' }
                ]},
                { name: 'Clearkey', params: [
                    { key: 'license-type', value: 'clearkey' },
                    { key: 'license-key', value: 'your_license_key_here' }
                ]},
                { name: 'Widevine', params: [
                    { key: 'license-type', value: 'com.widevine.alpha' },
                    { key: 'license-server', value: 'https://license.example.com/' }
                ]},
                { name: 'M3U8 Proxy', params: [
                    { key: 'User-Agent', value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' },
                    { key: 'Origin', value: 'https://proxy.example.com' },
                    { key: 'Referer', value: 'https://proxy.example.com/' }
                ]},
                { name: 'Streaming', params: [
                    { key: 'timeout', value: '60' },
                    { key: 'cache', value: 'yes' },
                    { key: 'redirect', value: 'follow' }
                ]}
            ];
            
            templates.forEach((template, index) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'template-btn';
                button.innerHTML = `<i class="fas fa-magic"></i> ${template.name}`;
                button.dataset.templateIndex = index;
                
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    applyParameterTemplate(template);
                    button.classList.add('active');
                    setTimeout(() => {
                        button.classList.remove('active');
                    }, 1000);
                });
                
                templateButtons.appendChild(button);
            });
        }
        
        // Apply parameter template
        function applyParameterTemplate(template) {
            parameterOptions.predefined.forEach(param => {
                param.checked = false;
            });
            
            parameterOptions.custom.forEach(param => {
                param.checked = false;
            });
            
            template.params.forEach(templateParam => {
                const predefinedIndex = parameterOptions.predefined.findIndex(
                    p => p.key.toLowerCase() === templateParam.key.toLowerCase()
                );
                
                if (predefinedIndex !== -1) {
                    parameterOptions.predefined[predefinedIndex].checked = true;
                    parameterOptions.predefined[predefinedIndex].value = templateParam.value;
                } else {
                    const customIndex = parameterOptions.custom.findIndex(
                        p => p.key.toLowerCase() === templateParam.key.toLowerCase()
                    );
                    
                    if (customIndex !== -1) {
                        parameterOptions.custom[customIndex].checked = true;
                        parameterOptions.custom[customIndex].value = templateParam.value;
                    } else {
                        parameterOptions.custom.push({
                            id: templateParam.key.replace(/\s+/g, '_').toLowerCase(),
                            key: templateParam.key,
                            value: templateParam.value,
                            checked: true,
                            isPredefined: false
                        });
                    }
                }
            });
            
            updateParameterList();
            
            logToConsole(`Template "${template.name}" applied`, 'success');
            showNotification(`Template "${template.name}" applied`, 'info');
            
            saveParameterOptions();
        }
        
        // Save parameter options to localStorage
        function saveParameterOptions() {
            try {
                localStorage.setItem('m3u_converter_params', JSON.stringify(parameterOptions));
            } catch (e) {
                console.error('Error saving parameter options:', e);
            }
        }
        
        // Load parameter options from localStorage
        function loadParameterOptions() {
            try {
                const saved = localStorage.getItem('m3u_converter_params');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    
                    if (parsed.predefined) {
                        parsed.predefined.forEach(savedParam => {
                            const existingIndex = parameterOptions.predefined.findIndex(
                                p => p.id === savedParam.id
                            );
                            if (existingIndex !== -1) {
                                parameterOptions.predefined[existingIndex] = {
                                    ...parameterOptions.predefined[existingIndex],
                                    ...savedParam
                                };
                            }
                        });
                    }
                    
                    if (parsed.custom) {
                        parameterOptions.custom = parsed.custom.map(param => ({
                            ...param,
                            isPredefined: param.isPredefined || false
                        }));
                    }
                    
                    updateParameterList();
                    logToConsole('Parameter options loaded from localStorage', 'info');
                }
            } catch (e) {
                console.error('Error loading parameter options:', e);
            }
        }
        
        // Get all active parameters
        function getActiveParameters() {
            const activeParams = {};
            
            const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
            
            allParameters
                .filter(param => param.checked && param.key && param.value)
                .forEach(param => {
                    activeParams[param.key] = param.value;
                });
            
            return activeParams;
        }
        
        // Check all parameters
        function checkAllParameters() {
            const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
            allParameters.forEach(param => {
                param.checked = true;
            });
            updateParameterList();
            saveParameterOptions();
            logToConsole('All parameters checked', 'info');
            showNotification('All parameters checked', 'info');
        }
        
        // Uncheck all parameters
        function uncheckAllParameters() {
            const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
            allParameters.forEach(param => {
                param.checked = false;
            });
            updateParameterList();
            saveParameterOptions();
            logToConsole('All parameters unchecked', 'info');
            showNotification('All parameters unchecked', 'info');
        }
        
        // Enable all parameters
        function enableAllParameters() {
            const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
            allParameters.forEach(param => {
                param.checked = true;
            });
            updateParameterList();
            saveParameterOptions();
            logToConsole('All parameters enabled', 'info');
            showNotification('All parameters enabled', 'info');
        }
        
        // Disable all parameters
        function disableAllParameters() {
            const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
            allParameters.forEach(param => {
                param.checked = false;
            });
            updateParameterList();
            saveParameterOptions();
            logToConsole('All parameters disabled', 'info');
            showNotification('All parameters disabled', 'info');
        }
        
        // Parameter search functionality
        function setupParameterSearch() {
            parameterSearch.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                
                const allParameters = [...parameterOptions.predefined, ...parameterOptions.custom];
                const paramItems = parameterList.querySelectorAll('.parameter-item');
                
                if (!searchTerm) {
                    paramItems.forEach(item => {
                        item.style.display = 'flex';
                    });
                } else {
                    allParameters.forEach((param, index) => {
                        const matches = param.key.toLowerCase().includes(searchTerm) || 
                                       param.value.toLowerCase().includes(searchTerm);
                        
                        if (paramItems[index]) {
                            paramItems[index].style.display = matches ? 'flex' : 'none';
                        }
                    });
                }
            });
            
            parameterSearch.insertAdjacentHTML('afterend', 
                '<button class="btn btn-small" id="clearSearchBtn" style="margin-top: 5px;"><i class="fas fa-times"></i> Clear Search</button>');
            
            document.getElementById('clearSearchBtn').addEventListener('click', () => {
                parameterSearch.value = '';
                updateParameterList();
            });
        }
        
        // ========== PARAMETER FILTER FUNCTIONS ==========
        
        // Toggle filter options visibility
        toggleFilterBtn.addEventListener('click', () => {
            const isVisible = filterOptionsContent.style.display !== 'none';
            filterOptionsContent.style.display = isVisible ? 'none' : 'block';
            toggleFilterBtn.innerHTML = isVisible ? 
                '<i class="fas fa-eye"></i> Show Filter Options' : 
                '<i class="fas fa-eye-slash"></i> Hide Filter Options';
        });
        
        // Set filter mode
        function setFilterMode(mode) {
            filterMode = mode;
            
            filterModeBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filterMode === mode) {
                    btn.classList.add('active');
                }
            });
            
            if (mode === 'regex') {
                filterOptionsKeep.style.display = 'none';
                filterOptionsRegex.style.display = 'block';
            } else {
                filterOptionsKeep.style.display = 'block';
                filterOptionsRegex.style.display = 'none';
            }
            
            logToConsole(`Filter mode set to: ${mode}`, 'info');
        }
        
        // Filter mode button click handlers
        filterModeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                setFilterMode(btn.dataset.filterMode);
            });
        });
        
        // Set filter scope
        function setFilterScope(scope) {
            filterScope = scope;
            
            if (scope === 'regex') {
                channelRegexInput.style.display = 'block';
            } else {
                channelRegexInput.style.display = 'none';
            }
            
            logToConsole(`Filter scope set to: ${scope}`, 'info');
        }
        
        // Scope option change handlers
        scopeOptions.forEach(option => {
            option.addEventListener('change', (e) => {
                if (e.target.checked) {
                    setFilterScope(e.target.value);
                }
            });
        });
        
        // Channel name pattern input
        channelNamePatternInput.addEventListener('input', (e) => {
            channelNamePattern = e.target.value;
        });
        
        // Analyze parameters in current content
        analyzeParamsBtn.addEventListener('click', async () => {
            if (!convertedOutput && !manualInput.value) {
                showNotification('No content to analyze', 'warning');
                return;
            }
            
            const content = convertedOutput || manualInput.value;
            await analyzeParameters(content);
        });
        
        // Analyze parameters function
        async function analyzeParameters(content) {
            if (!pyodide || !isPythonLoaded) {
                showNotification('Python runtime not ready', 'error');
                return;
            }
            
            analyzeParamsBtn.disabled = true;
            analyzeParamsBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';
            
            try {
                const base64Content = btoa(unescape(encodeURIComponent(content)));
                
                const result = await pyodide.runPythonAsync(`
                    import json, base64, re
                    
                    try:
                        content = base64.b64decode("${base64Content}").decode('utf-8', errors='ignore')
                    except:
                        content = base64.b64decode("${base64Content}").decode('latin-1')
                    
                    def extract_parameters_from_content(content, txt_delimiter=',', param_delimiter='$'):
                        """Extract all unique parameters from content with dual delimiter"""
                        params_map = {}
                        lines = content.split('\\n')
                        
                        for line in lines:
                            line = line.strip()
                            
                            if txt_delimiter in line:
                                url_part = line.split(txt_delimiter)[1] if len(line.split(txt_delimiter)) > 1 else ''
                                if param_delimiter in url_part:
                                    # Handle different delimiters
                                    if param_delimiter == '#':
                                        # Special handling for # delimiter
                                        hash_index = url_part.find('#')
                                        if hash_index != -1:
                                            param_part = url_part[hash_index + 1:]
                                            param_parts = param_part.split('#') if param_string else []
                                            for part in param_parts:
                                                if '=' in part:
                                                    key, value = part.split('=', 1)
                                                    if key not in params_map:
                                                        params_map[key] = {
                                                            'count': 1,
                                                            'values': {value}
                                                        }
                                                    else:
                                                        params_map[key]['count'] += 1
                                                        params_map[key]['values'].add(value)
                                    else:
                                        url_parts = url_part.split(param_delimiter)
                                        for part in url_parts[1:]:
                                            if '=' in part:
                                                key, value = part.split('=', 1)
                                                if key not in params_map:
                                                    params_map[key] = {
                                                        'count': 1,
                                                        'values': {value}
                                                    }
                                                else:
                                                    params_map[key]['count'] += 1
                                                    params_map[key]['values'].add(value)
                            elif line.startswith('#KODIPROP:') or line.startswith('#EXTVLCOPT:'):
                                if '=' in line:
                                    key_value = line.split('=', 1)
                                    if len(key_value) == 2:
                                        key = key_value[0].split(':')[1] if ':' in key_value[0] else key_value[0]
                                        value = key_value[1]
                                        if key not in params_map:
                                            params_map[key] = {
                                                'count': 1,
                                                'values': {value}
                                            }
                                        else:
                                            params_map[key]['count'] += 1
                                            params_map[key]['values'].add(value)
                        
                        result = {}
                        for key, data in params_map.items():
                            result[key] = {
                                'count': data['count'],
                                'values': list(data['values'])[:10],
                                'total_unique': len(data['values'])
                            }
                        
                        return result
                    
                    params = extract_parameters_from_content(content, ${JSON.stringify(getTxtDelimiter())}, ${JSON.stringify(getParamDelimiter())})
                    json.dumps(params)
                `);
                
                detectedParameters = JSON.parse(result);
                updateParameterFilterList(detectedParameters);
                
                const totalParams = Object.keys(detectedParameters).length;
                const totalOccurrences = Object.values(detectedParameters).reduce((sum, p) => sum + p.count, 0);
                
                filterStatus.innerHTML = `
                    <div style="color: #cbd5e1; margin-bottom: 10px;">
                        <i class="fas fa-chart-bar"></i> <strong>Analysis Results:</strong>
                    </div>
                    <div class="filter-stats">
                        <div class="filter-stat">
                            <div class="filter-stat-value">${totalParams}</div>
                            <div class="filter-stat-label">Unique Parameters</div>
                        </div>
                        <div class="filter-stat">
                            <div class="filter-stat-value">${totalOccurrences}</div>
                            <div class="filter-stat-label">Total Occurrences</div>
                        </div>
                        <div class="filter-stat">
                            <div class="filter-stat-value">${Object.values(detectedParameters).reduce((sum, p) => sum + p.total_unique, 0)}</div>
                            <div class="filter-stat-label">Unique Values</div>
                        </div>
                    </div>
                    <div style="margin-top: 10px; font-size: 0.9rem; color: #94a3b8;">
                        <i class="fas fa-info-circle"></i> Check parameters below to keep or remove them
                    </div>
                `;
                filterStatus.style.display = 'block';
                
                logToConsole(`Analyzed parameters: ${totalParams} unique, ${totalOccurrences} occurrences`, 'success');
                showNotification(`Found ${totalParams} unique parameters in content`, 'info');
                
            } catch (error) {
                console.error('Parameter analysis error:', error);
                logToConsole(`Analysis error: ${error.message}`, 'error');
                showNotification(`Failed to analyze parameters: ${error.message}`, 'error');
            } finally {
                analyzeParamsBtn.disabled = false;
                analyzeParamsBtn.innerHTML = '<i class="fas fa-chart-bar"></i> Analyze Parameters';
            }
        }
        
        // Update parameter filter list
        function updateParameterFilterList(params) {
            parameterFilterList.innerHTML = '';
            
            if (!params || Object.keys(params).length === 0) {
                parameterFilterList.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #94a3b8; font-style: italic;">
                        <i class="fas fa-search"></i> No parameters detected in content
                    </div>
                `;
                return;
            }
            
            const sortedParams = Object.entries(params).sort((a, b) => b[1].count - a[1].count);
            
            sortedParams.forEach(([paramName, paramData]) => {
                const paramItem = document.createElement('div');
                paramItem.className = 'filter-param-item';
                paramItem.innerHTML = `
                    <input type="checkbox" class="filter-param-checkbox" id="filter_${paramName}" data-param="${paramName}">
                    <div class="filter-param-label">
                        <span class="filter-param-name">${escapeHtml(paramName)}</span>
                        <span class="filter-param-value">
                            ${escapeHtml(paramData.values[0] || '')}
                            ${paramData.total_unique > 1 ? ` (+${paramData.total_unique - 1} more)` : ''}
                        </span>
                    </div>
                    <span class="filter-param-count" title="Occurrences">${paramData.count}</span>
                `;
                
                parameterFilterList.appendChild(paramItem);
            });
        }
        
        // Get selected parameters for filtering
        function getSelectedFilterParams() {
            const checkboxes = parameterFilterList.querySelectorAll('.filter-param-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.dataset.param);
        }
        
        // Apply filter to content
        async function applyFilterToContent(content) {
            if (!pyodide || !isPythonLoaded) {
                showNotification('Python runtime not ready', 'error');
                return content;
            }
            
            const selectedParams = getSelectedFilterParams();
            const regexPatternValue = regexPattern.value;
            const scope = filterScope;
            const channelPattern = channelNamePattern;
            
            if (filterMode === 'keep' && selectedParams.length === 0 && regexPatternValue === '') {
                showNotification('Select parameters to keep or enter regex pattern', 'warning');
                return content;
            }
            
            if (filterMode === 'remove' && selectedParams.length === 0 && regexPatternValue === '') {
                showNotification('Select parameters to remove or enter regex pattern', 'warning');
                return content;
            }
            
            applyFilterBtn.disabled = true;
            applyFilterBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Applying...';
            
            try {
                const base64Content = btoa(unescape(encodeURIComponent(content)));
                
                const result = await pyodide.runPythonAsync(`
                    import json, base64, re
                    
                    try:
                        content = base64.b64decode("${base64Content}").decode('utf-8', errors='ignore')
                    except:
                        content = base64.b64decode("${base64Content}").decode('latin-1')
                    
                    def filter_parameters(content, txt_delimiter=',', param_delimiter='$', mode='keep', params=None, regex_pattern=None, scope='all', channel_pattern=''):
                        """Filter parameters from content based on criteria with dual delimiter"""
                        if params is None:
                            params = []
                        
                        lines = content.split('\\n')
                        result_lines = []
                        
                        current_channel = None
                        skip_current = False
                        
                        for line in lines:
                            original_line = line
                            line = line.strip()
                            
                            if line.startswith('#EXTINF:'):
                                current_channel = line
                                skip_current = False
                                
                                if scope == 'regex' and channel_pattern:
                                    try:
                                        if not re.search(channel_pattern, line, re.IGNORECASE):
                                            skip_current = True
                                    except:
                                        pass
                            
                            if (scope == 'all' or 
                                (scope == 'selected' and not skip_current) or 
                                (scope == 'regex' and not skip_current)):
                                
                                if txt_delimiter in original_line:
                                    parts = original_line.split(txt_delimiter)
                                    if len(parts) >= 2:
                                        channel_part = parts[0]
                                        url_part = parts[1]
                                        
                                        if param_delimiter in url_part:
                                            if param_delimiter == '#':
                                                hash_index = url_part.find('#')
                                                if hash_index != -1:
                                                    base_url = url_part[:hash_index]
                                                    param_string = url_part[hash_index + 1:]
                                                    param_parts = param_string.split('#') if param_string else []
                                                    
                                                    filtered_params = []
                                                    for param in param_parts:
                                                        if '=' in param:
                                                            key = param.split('=', 1)[0]
                                                            
                                                            should_keep = False
                                                            if mode == 'keep':
                                                                should_keep = key in params
                                                                if regex_pattern:
                                                                    try:
                                                                        should_keep = should_keep or bool(re.search(regex_pattern, key))
                                                                    except:
                                                                        pass
                                                            else:
                                                                should_keep = key not in params
                                                                if regex_pattern:
                                                                    try:
                                                                        should_keep = should_keep and not bool(re.search(regex_pattern, key))
                                                                    except:
                                                                        pass
                                                            
                                                            if should_keep:
                                                                filtered_params.append(param)
                                                    
                                                    if filtered_params:
                                                        new_url = base_url + '#' + '#'.join(filtered_params)
                                                    else:
                                                        new_url = base_url
                                                    
                                                    result_lines.append(channel_part + txt_delimiter + new_url)
                                                else:
                                                    result_lines.append(original_line)
                                            else:
                                                url_parts = url_part.split(param_delimiter)
                                                base_url = url_parts[0]
                                                params_list = url_parts[1:]
                                                
                                                filtered_params = []
                                                for param in params_list:
                                                    if '=' in param:
                                                        key = param.split('=', 1)[0]
                                                        
                                                        should_keep = False
                                                        if mode == 'keep':
                                                            should_keep = key in params
                                                            if regex_pattern:
                                                                try:
                                                                    should_keep = should_keep or bool(re.search(regex_pattern, key))
                                                                except:
                                                                    pass
                                                        else:
                                                            should_keep = key not in params
                                                            if regex_pattern:
                                                                try:
                                                                    should_keep = should_keep and not bool(re.search(regex_pattern, key))
                                                                except:
                                                                    pass
                                                        
                                                        if should_keep:
                                                            filtered_params.append(param)
                                                
                                                if filtered_params:
                                                    new_url = base_url + param_delimiter + param_delimiter.join(filtered_params)
                                                else:
                                                    new_url = base_url
                                                
                                                result_lines.append(channel_part + txt_delimiter + new_url)
                                        else:
                                            result_lines.append(original_line)
                                    else:
                                        result_lines.append(original_line)
                                
                                elif original_line.startswith('#KODIPROP:') or original_line.startswith('#EXTVLCOPT:'):
                                    if '=' in original_line:
                                        key_value = original_line.split('=', 1)
                                        if len(key_value) == 2:
                                            key = key_value[0].split(':')[1] if ':' in key_value[0] else key_value[0]
                                            
                                            should_keep = False
                                            if mode == 'keep':
                                                should_keep = key in params
                                                if regex_pattern:
                                                    try:
                                                        should_keep = should_keep or bool(re.search(regex_pattern, key))
                                                    except:
                                                        pass
                                            else:
                                                should_keep = key not in params
                                                if regex_pattern:
                                                    try:
                                                        should_keep = should_keep and not bool(re.search(regex_pattern, key))
                                                    except:
                                                        pass
                                            
                                            if should_keep:
                                                result_lines.append(original_line)
                                    else:
                                        result_lines.append(original_line)
                                
                                else:
                                    result_lines.append(original_line)
                            else:
                                result_lines.append(original_line)
                        
                        return '\\n'.join(result_lines)
                    
                    filtered_content = filter_parameters(
                        content,
                        ${JSON.stringify(getTxtDelimiter())},
                        ${JSON.stringify(getParamDelimiter())},
                        ${JSON.stringify(filterMode)},
                        ${JSON.stringify(selectedParams)},
                        ${JSON.stringify(regexPatternValue)},
                        ${JSON.stringify(scope)},
                        ${JSON.stringify(channelPattern)}
                    )
                    
                    json.dumps({'filtered_content': filtered_content})
                `);
                
                const data = JSON.parse(result);
                
                logToConsole(`Filter applied: ${selectedParams.length} parameters, mode=${filterMode}`, 'success');
                showNotification(`Filter applied successfully!`, 'success');
                
                return data.filtered_content;
                
            } catch (error) {
                console.error('Filter application error:', error);
                logToConsole(`Filter error: ${error.message}`, 'error');
                showNotification(`Failed to apply filter: ${error.message}`, 'error');
                return content;
            } finally {
                applyFilterBtn.disabled = false;
                applyFilterBtn.innerHTML = '<i class="fas fa-filter"></i> Apply Filter';
            }
        }
        
        // Apply filter button click
        applyFilterBtn.addEventListener('click', async () => {
            if (!convertedOutput && !manualInput.value) {
                showNotification('No content to filter', 'warning');
                return;
            }
            
            const content = convertedOutput || manualInput.value;
            const filteredContent = await applyFilterToContent(content);
            
            convertedOutput = filteredContent;
            txtOutput.value = filteredContent;
            
            if (detectedParameters && Object.keys(detectedParameters).length > 0) {
                const originalParams = Object.keys(detectedParameters).length;
                const originalOccurrences = Object.values(detectedParameters).reduce((sum, p) => sum + p.count, 0);
                
                await analyzeParameters(filteredContent);
            }
            
            showNotification('Filter applied to content', 'info');
        });
        
        // Reset filter
        resetFilterBtn.addEventListener('click', () => {
            const checkboxes = parameterFilterList.querySelectorAll('.filter-param-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
            
            regexPattern.value = '';
            regexTestResult.style.display = 'none';
            
            document.querySelector('input[name="filterScope"][value="all"]').checked = true;
            channelRegexInput.style.display = 'none';
            channelNamePatternInput.value = '';
            
            setFilterMode('keep');
            filterStatus.style.display = 'none';
            
            logToConsole('Filter settings reset', 'info');
            showNotification('Filter settings have been reset', 'info');
        });
        
        // Test regex pattern
        testRegexBtn.addEventListener('click', () => {
            const pattern = regexPattern.value;
            
            if (!pattern) {
                showNotification('Enter regex pattern first', 'warning');
                return;
            }
            
            try {
                const regex = new RegExp(pattern);
                
                const testParams = ['User-Agent', 'Referer', 'license-key', 'license-type', 'timeout', 'cookie'];
                const matches = testParams.filter(param => regex.test(param));
                
                regexResultText.textContent = `Matches: ${matches.length} parameters (${matches.join(', ')})`;
                regexTestResult.style.display = 'block';
                
                logToConsole(`Regex test: pattern "${pattern}" matches ${matches.length} parameters`, 'info');
                
            } catch (error) {
                regexResultText.textContent = `Error: ${error.message}`;
                regexTestResult.style.display = 'block';
                logToConsole(`Regex error: ${error.message}`, 'error');
            }
        });
        
        // ========== FILE MODE FUNCTIONS - OPTIMIZED FOR 200MB ==========
        
        // Handle file selection with all format support and 200MB limit
        function handleFileSelection(file) {
            if (!file) {
                showNotification('Select file first', 'error');
                return false;
            }
            
            const validation = validateFileSize(file);
            if (!validation.valid) {
                fileSizeWarning.style.display = 'block';
                fileSizeWarning.querySelector('span').textContent = validation.message;
                performanceWarning.style.display = 'none';
                return false;
            }
            
            fileSizeWarning.style.display = 'none';
            
            const fileExt = getFileExtension(file.name);
            const supportedFormats = ['m3u', 'm3u8', 'txt', 'json', 'xml', 'csv', 'ts', 'mpd', 'list', 'log', 'dat'];
            
            // Check format based on extension and MIME type
            const isTextFile = file.type.startsWith('text/') || 
                              file.type === 'application/json' || 
                              file.type === 'application/xml';
            
            if (!supportedFormats.includes(fileExt) && !isTextFile) {
                showNotification(`File format "${fileExt}" may not be supported. Try uploading text or playlist files.`, 'warning');
                // Continue anyway, we'll try to detect format from content
            }
            
            selectedFile = file;
            
            updateFileInfoUI(file);
            
            processFileBtn.disabled = false;
            
            // Update UI with detected format
            const format = fileExt.toUpperCase();
            fileFormatName.textContent = `File: ${file.name}`;
            fileFormatDesc.textContent = `${format} format â€¢ ${formatFileSize(file.size)}`;
            fileFormatInfo.style.display = 'block';
            
            logToConsole(`File "${file.name}" selected (${formatFileSize(file.size)}, ${fileExt})`, 'success');
            showNotification(`File "${file.name}" selected. Click "Process File" to convert.`, 'info');
            updateAriaLive(`File ${file.name} selected. Ready for processing.`);
            
            return true;
        }
        
        // Update UI file info
        function updateFileInfoUI(file) {
            const fileExt = getFileExtension(file.name);
            const format = fileExt.toUpperCase();
            
            fileNameElement.textContent = file.name;
            fileMetaElement.textContent = `Size: ${formatFileSize(file.size)} â€¢ Format: ${format}`;
            
            fileInfoDisplay.style.display = 'block';
        }
        
        // Remove selected file
        function removeSelectedFile() {
            selectedFile = null;
            fileInput.value = '';
            
            fileInfoDisplay.style.display = 'none';
            processFileBtn.disabled = true;
            fileFormatInfo.style.display = 'none';
            fileSizeWarning.style.display = 'none';
            performanceWarning.style.display = 'none';
            
            logToConsole('File removed from list', 'info');
            showNotification('File removed', 'info');
        }
        
        // Process file with Python - OPTIMIZED FOR 200MB FILES
        async function processFileWithPython() {
            if (!pyodide || !isPythonLoaded) {
                showNotification('Python runtime not ready', 'error');
                return;
            }
            
            if (!selectedFile) {
                showNotification('Select file first', 'error');
                return;
            }
            
            // Update memory monitor before processing
            const memoryInfo = updateMemoryMonitor();
            if (memoryInfo && memoryInfo.usedPercent > 90) {
                showNotification('Browser memory almost full. Try closing other tabs before processing large file.', 'error');
                return;
            }
            
            statusEl.textContent = selectedFile.size > 50 * 1024 * 1024 ? 
                'Processing large file...' : 'Processing file...';
            processFileBtn.disabled = true;
            clearConsole();
            
            const txtDelimiter = getTxtDelimiter();
            const paramDelimiter = getParamDelimiter();
            const parameters = getActiveParameters();
            
            logToConsole(`Processing file: "${selectedFile.name}"`, 'log');
            logToConsole(`Size: ${formatFileSize(selectedFile.size)}`, 'log');
            logToConsole(`Direction: ${conversionDirection}`, 'log');
            logToConsole(`TXT Delimiter: "${txtDelimiter}", Param Delimiter: "${paramDelimiter}"`, 'log');
            logToConsole(`Parameters: ${JSON.stringify(parameters)}`, 'log');
            updateAriaLive('Starting file conversion');
            
            try {
                // Show loading progress for large files
                if (selectedFile.size > 50 * 1024 * 1024) {
                    statusEl.textContent = 'Reading large file...';
                }
                
                const content = await readFileAsText(selectedFile);
                
                // Process large content in chunks
                if (content.length > 50 * 1024 * 1024) {
                    statusEl.textContent = 'Processing large file...';
                    await processLargeContent(content, selectedFile.name);
                }
                
                const detectedFormat = validateContent(content, selectedFile.name);
                
                logToConsole(`Detected format: ${detectedFormat}`, 'info');
                logToConsole(`Content size: ${formatFileSize(content.length)}`, 'info');
                
                const base64Content = btoa(unescape(encodeURIComponent(content)));
                
                // Show processing message for large files
                if (content.length > 100 * 1024 * 1024) {
                    statusEl.textContent = 'Converting very large file...';
                    showNotification(`Processing very large file (${formatFileSize(content.length)})...`, 'info');
                }
                
                const result = await retryOperation(async () => {
                    return await pyodide.runPythonAsync(`
                        import json, base64, re
                        
                        try:
                            content = base64.b64decode("${base64Content}").decode('utf-8', errors='ignore')
                        except:
                            content = base64.b64decode("${base64Content}").decode('latin-1')
                        
                        # Optimized processing for large files
                        def process_large_content_optimized(content, txt_delimiter=',', param_delimiter='$', direction='m3u2txt', parameters=None, original_format='m3u'):
                            """Optimized processing for large files"""
                            if parameters is None:
                                parameters = {}
                            
                            # Split content into chunks for large files
                            lines = content.split('\\n')
                            total_lines = len(lines)
                            
                            if total_lines > 100000:
                                print(f"Processing large file: {total_lines:,} lines")
                            
                            # Call the existing process_local_content function
                            result = process_local_content(content, txt_delimiter, param_delimiter, direction, parameters)
                            
                            # Add original format info
                            result['original_format'] = original_format
                            return result
                        
                        result = process_large_content_optimized(
                            content, 
                            ${JSON.stringify(txtDelimiter)}, 
                            ${JSON.stringify(paramDelimiter)}, 
                            ${JSON.stringify(conversionDirection)},
                            ${JSON.stringify(parameters)},
                            ${JSON.stringify(detectedFormat)}
                        )
                        
                        json.dumps(result)
                    `);
                });
                
                const data = JSON.parse(result);
                logToConsole(`Python function completed`, 'success');
                logToConsole(`Original format: ${data.original_format}`, 'info');
                
                updateUIAfterConversion(data);
                
            } catch (error) {
                console.error('File conversion error:', error);
                logToConsole(`ERROR: ${error.message}`, 'error');
                statusEl.textContent = 'Error';
                showNotification(`Failed: ${error.message}`, 'error');
                updateAriaLive(`Error: ${error.message}`);
                
                errorDetailsText.textContent = `Error: ${error.message}`;
                errorDetails.style.display = 'block';
                retryButton.style.display = 'block';
                retryButton.onclick = () => {
                    errorDetails.style.display = 'none';
                    retryButton.style.display = 'none';
                    processFileWithPython();
                };
            } finally {
                processFileBtn.disabled = false;
                performanceWarning.style.display = 'none';
            }
        }
        
        // ========== CORE CONVERSION FUNCTIONS ==========
        
        // Load the Python conversion code with DUAL DELIMITER support and MULTI-FORMAT
        async function loadPythonCode() {
            const pythonCode = `
import requests
import re
import json
import urllib.parse
import base64
import xml.etree.ElementTree as ET
from io import StringIO

def detect_format(content, txt_delimiter=',', param_delimiter='$'):
    """Detect format of playlist content with dual delimiter"""
    lines = content.split('\\n')
    
    # For very large files, only check first 100 lines
    check_lines = lines[:100] if len(lines) > 100 else lines
    
    m3u_indicators = 0
    txt_indicators = 0
    json_indicators = 0
    xml_indicators = 0
    csv_indicators = 0
    
    for i, line in enumerate(check_lines):
        line = line.strip()
        
        # M3U indicators
        if line.startswith('#EXTM3U'):
            m3u_indicators += 3
        if line.startswith('#EXTINF:'):
            m3u_indicators += 2
        if line.startswith('#KODIPROP:'):
            m3u_indicators += 1
        if line.startswith('#EXTVLCOPT:'):
            m3u_indicators += 1
        
        # TXT indicators with param delimiter
        if line.endswith('#genre#'):
            txt_indicators += 3
        if txt_delimiter in line and '#' not in line:
            txt_indicators += 1
        if param_delimiter in line and ('license-key=' in line or 'User-Agent=' in line):
            txt_indicators += 2
        # Detect TXT format with parameter delimiter
        if txt_delimiter in line and param_delimiter in line:
            txt_indicators += 1
        
        # JSON indicators
        if line.strip().startswith('{') or line.strip().startswith('['):
            json_indicators += 1
        if '"name"' in line or '"url"' in line:
            json_indicators += 1
            
        # XML indicators
        if line.strip().startswith('<?xml'):
            xml_indicators += 3
        if '<channel>' in line or '<playlist>' in line:
            xml_indicators += 2
        if '<name>' in line or '<url>' in line:
            xml_indicators += 1
            
        # CSV indicators
        if i == 0 and line.count(',') > 1:
            csv_indicators += 2
    
    # Priority detection
    if m3u_indicators >= txt_indicators and m3u_indicators >= json_indicators and m3u_indicators >= xml_indicators and m3u_indicators >= csv_indicators:
        return 'm3u'
    elif txt_indicators >= m3u_indicators and txt_indicators >= json_indicators and txt_indicators >= xml_indicators and txt_indicators >= csv_indicators:
        return 'txt'
    elif json_indicators >= m3u_indicators and json_indicators >= txt_indicators and json_indicators >= xml_indicators and json_indicators >= csv_indicators:
        return 'json'
    elif xml_indicators >= m3u_indicators and xml_indicators >= txt_indicators and xml_indicators >= json_indicators and xml_indicators >= csv_indicators:
        return 'xml'
    elif csv_indicators >= m3u_indicators and csv_indicators >= txt_indicators and csv_indicators >= json_indicators and csv_indicators >= xml_indicators:
        return 'csv'
    else:
        return 'm3u'

def extract_channel_name_from_extinf(extinf_line):
    """Extract channel name from EXTINF line"""
    line = extinf_line[8:].strip()
    
    last_comma_index = line.rfind(',')
    if last_comma_index == -1:
        return 'Unnamed Channel'
    
    channel_name = line[last_comma_index + 1:].strip()
    channel_name = channel_name.replace('"', '').strip()
    channel_name = re.sub(r'<[^>]+>', '', channel_name)
    
    if not channel_name or len(channel_name) < 2:
        before_comma = line[:last_comma_index]
        tvg_name_match = re.search(r'tvg-name="([^"]*)"', before_comma)
        if tvg_name_match and tvg_name_match.group(1):
            channel_name = tvg_name_match.group(1).strip()
        else:
            tvg_id_match = re.search(r'tvg-id="([^"]*)"', before_comma)
            if tvg_id_match and tvg_id_match.group(1):
                channel_name = tvg_id_match.group(1).strip()
            else:
                return 'Unnamed Channel'
    
    channel_name = channel_name.strip()
    
    if len(channel_name) < 2:
        return 'Unnamed Channel'
    
    return channel_name

def parse_m3u_streaming(content, param_delimiter='$'):
    """Parse M3U with support for dual delimiter - optimized for large files"""
    lines = content.split('\\n')
    current_channel = None
    urls = []
    kodiprop_license = {}
    extvlcopt_params = {}
    
    # For large files, use iterator
    for i, line in enumerate(lines):
        line = line.strip()
        
        if line.startswith('#EXTINF:'):
            if current_channel and urls:
                current_channel['urls'] = urls.copy()
                if kodiprop_license:
                    current_channel['kodiprop'] = kodiprop_license.copy()
                if extvlcopt_params:
                    current_channel['extvlcopt'] = extvlcopt_params.copy()
                yield current_channel
                kodiprop_license = {}
                extvlcopt_params = {}
            
            current_channel = {
                'name': 'Unnamed Channel',
                'group': 'No Group',
                'duration': -1,
                'tvg_id': '',
                'tvg_name': '',
                'tvg_logo': '',
                'kodiprop': {},
                'extvlcopt': {},
                'urls': []
            }
            
            urls = []
            
            try:
                duration_match = re.match(r'#EXTINF:(-?\\d+)', line)
                if duration_match:
                    current_channel['duration'] = int(duration_match.group(1))
                
                channel_name = extract_channel_name_from_extinf(line)
                current_channel['name'] = channel_name
                
                if ',' in line:
                    attr_part = line.split(',', 1)[0]
                else:
                    attr_part = line
                
                group_match = re.search(r'group-title="([^"]*)"', attr_part)
                if group_match and group_match.group(1):
                    current_channel['group'] = group_match.group(1).strip()
                
                tvg_name_match = re.search(r'tvg-name="([^"]*)"', attr_part)
                if tvg_name_match and tvg_name_match.group(1):
                    current_channel['tvg_name'] = tvg_name_match.group(1).strip()
                
                tvg_id_match = re.search(r'tvg-id="([^"]*)"', attr_part)
                if tvg_id_match and tvg_id_match.group(1):
                    current_channel['tvg_id'] = tvg_id_match.group(1).strip()
                
                tvg_logo_match = re.search(r'tvg-logo="([^"]*)"', attr_part)
                if tvg_logo_match and tvg_logo_match.group(1):
                    current_channel['tvg_logo'] = tvg_logo_match.group(1).strip()
                    
            except Exception as e:
                current_channel['name'] = 'Unnamed Channel'
                current_channel['group'] = 'No Group'
        
        elif line.startswith('#KODIPROP:'):
            if 'license_type=' in line:
                match = re.search(r'license_type=([^ \\n]+)', line)
                if match:
                    kodiprop_license['license_type'] = match.group(1).strip()
            
            if 'license_key=' in line:
                match = re.search(r'license_key=([^ \\n]+)', line)
                if match:
                    kodiprop_license['license_key'] = match.group(1).strip()
        
        elif line.startswith('#EXTVLCOPT:'):
            line_without_prefix = line[11:].strip()
            
            user_agent_match = re.search(r'http-user-agent=([^\\s]+)', line_without_prefix)
            if user_agent_match:
                extvlcopt_params['http-user-agent'] = user_agent_match.group(1).strip()
            
            referrer_match = re.search(r'http-referrer=([^\\s]+)', line_without_prefix)
            if not referrer_match:
                referrer_match = re.search(r'http-referer=([^\\s]+)', line_without_prefix)
            if referrer_match:
                extvlcopt_params['http-referrer'] = referrer_match.group(1).strip()
            
            param_matches = re.findall(r'([a-zA-Z0-9_-]+)=([^\\s]+)', line_without_prefix)
            for key, value in param_matches:
                key_lower = key.lower()
                if key_lower not in ['http-user-agent', 'http-referrer', 'http-referer']:
                    extvlcopt_params[key] = value.strip()
        
        elif line and not line.startswith('#') and current_channel:
            if line.startswith('http://') or line.startswith('https://'):
                urls.append(line.strip())
        
        elif line == '' and current_channel:
            if urls:
                current_channel['urls'] = urls.copy()
                if kodiprop_license:
                    current_channel['kodiprop'] = kodiprop_license.copy()
                if extvlcopt_params:
                    current_channel['extvlcopt'] = extvlcopt_params.copy()
                yield current_channel
            current_channel = None
            urls = []
            kodiprop_license = {}
            extvlcopt_params = {}
    
    if current_channel and urls:
        current_channel['urls'] = urls.copy()
        if kodiprop_license:
            current_channel['kodiprop'] = kodiprop_license.copy()
        if extvlcopt_params:
            current_channel['extvlcopt'] = extvlcopt_params.copy()
        yield current_channel

def parse_m3u(content):
    """Parse M3U content and return list of channels"""
    channels = []
    for channel in parse_m3u_streaming(content):
        channels.append(channel)
    return channels

def parse_txt(content, txt_delimiter=',', param_delimiter='$'):
    """Parse TXT content with dual delimiter support"""
    channels = []
    lines = content.split('\\n')
    current_group = 'No Group'
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
        
        if param_delimiter == '#':
            if line.startswith('#') and not line.endswith('#genre#'):
                continue
        
        if line.endswith('#genre#'):
            parts = line.split(txt_delimiter)
            if len(parts) >= 2 and parts[1].strip() == '#genre#':
                current_group = parts[0].strip()
            continue
        
        if line.startswith('#') and not line.endswith('#genre#'):
            continue
        
        if txt_delimiter in line:
            parts = line.split(txt_delimiter)
            if len(parts) >= 2:
                channel_name = parts[0].strip()
                url_with_params = parts[1].strip()
                
                if param_delimiter in url_with_params:
                    if param_delimiter == '#':
                        hash_index = url_with_params.find('#')
                        if hash_index != -1:
                            url = url_with_params[:hash_index]
                            param_string = url_with_params[hash_index + 1:]
                            param_parts = param_string.split('#') if param_string else []
                            
                            params = {}
                            for param_str in param_parts:
                                if '=' in param_str:
                                    key, value = param_str.split('=', 1)
                                    params[key.strip()] = value.strip()
                            
                            channels.append({
                                'name': channel_name,
                                'group': current_group,
                                'url': url,
                                'params': params
                            })
                    else:
                        url_parts = url_with_params.split(param_delimiter)
                        url = url_parts[0]
                        
                        params = {}
                        for param in url_parts[1:]:
                            if '=' in param:
                                key, value = param.split('=', 1)
                                params[key.strip()] = value.strip()
                        
                        channels.append({
                            'name': channel_name,
                            'group': current_group,
                            'url': url,
                            'params': params
                        })
                else:
                    channels.append({
                        'name': channel_name,
                        'group': current_group,
                        'url': url_with_params,
                        'params': {}
                    })
    
    return channels

def convert_m3u_to_txt(m3u_content, txt_delimiter=',', param_delimiter='$', parameters=None):
    """Convert M3U content to TXT format with dual delimiter"""
    if parameters is None:
        parameters = {}
    
    channels = parse_m3u(m3u_content)
    
    if not channels:
        return '', 0, 0
    
    total_urls = sum(len(channel.get('urls', [])) for channel in channels)
    
    grouped = {}
    for channel in channels:
        group = channel['group'] or 'No Group'
        if group not in grouped:
            grouped[group] = []
        
        if channel['name'] == 'Unnamed Channel' and channel['tvg_name']:
            channel['name'] = channel['tvg_name']
        elif channel['name'] == 'Unnamed Channel' and channel['tvg_id']:
            channel['name'] = channel['tvg_id']
        
        grouped[group].append(channel)
    
    output_lines = []
    for group_name in sorted(grouped.keys()):
        output_lines.append(f"{group_name}{txt_delimiter}#genre#")
        
        sorted_channels = sorted(grouped[group_name], key=lambda x: x['name'].lower())
        
        for channel in sorted_channels:
            channel_name = channel['name'].strip()
            urls = channel.get('urls', [])
            
            if not urls:
                continue
            
            all_params = {}
            
            kodiprop = channel.get('kodiprop', {})
            if 'license_key' in kodiprop:
                all_params['license-key'] = kodiprop["license_key"]
                license_type = kodiprop.get('license_type', 'clearkey')
                all_params['license-type'] = license_type
            
            extvlcopt = channel.get('extvlcopt', {})
            for key, value in extvlcopt.items():
                if key.lower() in ['http-user-agent', 'user-agent', 'user_agent']:
                    all_params['User-Agent'] = value
                elif key.lower() in ['http-referrer', 'http-referer', 'referer']:
                    all_params['Referer'] = value
                elif key.lower() == 'origin':
                    all_params['Origin'] = value
                elif key.lower() == 'cookie':
                    all_params['Cookie'] = value
                else:
                    clean_key = key.replace('http-', '').replace('-', '_')
                    all_params[clean_key] = value
            
            for key, value in parameters.items():
                if key not in all_params:
                    all_params[key] = value
            
            for url in urls:
                url_with_params = url
                if all_params:
                    param_strings = []
                    for key, value in all_params.items():
                        param_strings.append(f'{key}={value}')
                    
                    if param_delimiter == '#':
                        url_with_params += '#' + '#'.join(param_strings)
                    else:
                        url_with_params += param_delimiter + param_delimiter.join(param_strings)
                
                output_lines.append(f"{channel_name}{txt_delimiter}{url_with_params}")
        
        output_lines.append("")
    
    if output_lines and output_lines[-1] == "":
        output_lines.pop()
    
    result = '\\n'.join(output_lines)
    return result, total_urls, len(grouped)

def convert_txt_to_m3u(txt_content, txt_delimiter=',', param_delimiter='$', parameters=None):
    """Convert TXT content to M3U format with dual delimiter"""
    if parameters is None:
        parameters = {}
    
    channels = parse_txt(txt_content, txt_delimiter, param_delimiter)
    
    if not channels:
        return '', 0, 0
    
    output_lines = ['#EXTM3U']
    group_count = len(set(channel['group'] for channel in channels))
    
    current_group = None
    
    for channel in channels:
        group = channel['group']
        
        if group != current_group:
            current_group = group
            output_lines.append("")
        
        extinf_line = f'#EXTINF:-1 '
        
        if channel.get('tvg_id'):
            extinf_line += f'tvg-id="{channel["tvg_id"]}" '
        
        if channel.get('tvg_name'):
            extinf_line += f'tvg-name="{channel["tvg_name"]}" '
        
        if channel.get('tvg_logo'):
            extinf_line += f'tvg-logo="{channel["tvg_logo"]}" '
        
        extinf_line += f'group-title="{group}",{channel["name"]}'
        output_lines.append(extinf_line)
        
        all_params = {**channel.get('params', {}), **parameters}
        
        if 'license-key' in all_params:
            output_lines.append(f'#KODIPROP:inputstream.adaptive.license_key={all_params["license-key"]}')
        
        if 'license-type' in all_params:
            output_lines.append(f'#KODIPROP:inputstream.adaptive.license_type={all_params["license-type"]}')
        
        if 'User-Agent' in all_params:
            output_lines.append(f'#EXTVLCOPT:http-user-agent={all_params["User-Agent"]}')
        
        if 'Referer' in all_params:
            output_lines.append(f'#EXTVLCOPT:http-referrer={all_params["Referer"]}')
        
        if 'Origin' in all_params:
            output_lines.append(f'#EXTVLCOPT:origin={all_params["Origin"]}')
        
        if 'Cookie' in all_params:
            output_lines.append(f'#EXTVLCOPT:cookie={all_params["Cookie"]}')
        
        if 'timeout' in all_params:
            output_lines.append(f'#EXTVLCOPT:http-timeout={all_params["timeout"]}')
        
        for key, value in all_params.items():
            if key not in ['license-key', 'license-type', 'User-Agent', 'Referer', 'Origin', 'Cookie', 'timeout']:
                if not key.startswith('#EXTVLCOPT:'):
                    output_lines.append(f'#EXTVLCOPT:{key}={value}')
                else:
                    output_lines.append(f'{key}={value}')
        
        output_lines.append(channel['url'])
    
    result = '\\n'.join(output_lines)
    return result, len(channels), group_count

def fetch_with_proxy(url, method='auto'):
    """Fetch URL with various methods to bypass CORS"""
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': '*/*',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate',
        'Connection': 'keep-alive'
    }
    
    encoded_url = urllib.parse.quote(url, safe='')
    
    proxies = {
        'direct': [url],
        'corsproxy': [f"https://corsproxy.io/?{encoded_url}"],
        'allorigins': [f"https://api.allorigins.win/raw?url={encoded_url}"],
        'codetabs': [f"https://api.codetabs.com/v1/proxy?quest={encoded_url}"],
        'thingproxy': [f"https://thingproxy.freeboard.io/fetch/{encoded_url}"]
    }
    
    auto_order = ['corsproxy', 'allorigins', 'codetabs', 'direct']
    
    if method == 'auto':
        methods_to_try = auto_order
    else:
        methods_to_try = [method]
    
    last_error = None
    
    for method_name in methods_to_try:
        urls_to_try = proxies.get(method_name, [url])
        
        for proxy_url in urls_to_try:
            try:
                response = requests.get(proxy_url, headers=headers, timeout=10)
                
                if response.status_code == 200:
                    return {
                        'success': True,
                        'content': response.text,
                        'method_used': method_name,
                        'status_code': response.status_code
                    }
                else:
                    last_error = f'Status code: {response.status_code}'
                    
            except Exception as e:
                last_error = str(e);
                continue
    
    return {
        'success': False,
        'error': f'All methods failed. Last error: {last_error}',
        'methods_tried': methods_to_try
    }

def convert_content(content, txt_delimiter=',', param_delimiter='$', direction='m3u2txt', parameters=None, original_format=None):
    """Convert content based on direction with dual delimiter"""
    if parameters is None:
        parameters = {}
    
    if direction == 'm3u2txt':
        if original_format == 'm3u' or original_format is None:
            return convert_m3u_to_txt(content, txt_delimiter, param_delimiter, parameters)
        else:
            # For other formats, try to parse as txt
            return convert_m3u_to_txt(content, txt_delimiter, param_delimiter, parameters)
    elif direction == 'txt2m3u':
        if original_format == 'txt' or original_format is None:
            return convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
        else:
            # For other formats, try to parse as txt
            return convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
    else:
        raise ValueError(f"Unknown direction: {direction}")

def fetch_and_convert(url, txt_delimiter=',', param_delimiter='$', method='auto', direction='m3u2txt', parameters=None):
    """Main function: fetch URL and convert with dual delimiter"""
    if parameters is None:
        parameters = {}
    
    try:
        fetch_result = fetch_with_proxy(url, method)
        
        if not fetch_result['success']:
            error_msg = fetch_result.get('error', 'Unknown error')
            return {
                'success': False,
                'error': error_msg,
                'method': method
            }
        
        content = fetch_result['content']
        method_used = fetch_result['method_used']
        
        format_detected = detect_format(content, txt_delimiter, param_delimiter)
        
        if direction == 'm3u2txt':
            if format_detected in ['m3u', 'txt']:
                txt_output, channel_count, group_count = convert_m3u_to_txt(content, txt_delimiter, param_delimiter, parameters)
            else:
                # For other formats, try to convert as m3u
                txt_output, channel_count, group_count = convert_m3u_to_txt(content, txt_delimiter, param_delimiter, parameters)
            
            return {
                'success': True,
                'output': txt_output,
                'channels': channel_count,
                'groups': group_count,
                'format': 'txt',
                'method_used': method_used,
                'direction': direction,
                'original_format': format_detected,
                'parameters_applied': len(parameters)
            }
        else:
            if format_detected == 'txt':
                m3u_output, channel_count, group_count = convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
            else:
                # For other formats, try to convert as txt
                m3u_output, channel_count, group_count = convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
            
            return {
                'success': True,
                'output': m3u_output,
                'channels': channel_count,
                'groups': group_count,
                'format': 'm3u',
                'method_used': method_used,
                'direction': direction,
                'original_format': format_detected,
                'parameters_applied': len(parameters)
            }
        
    except Exception as e:
        error_msg = str(e)
        return {
            'success': False,
            'error': f'Conversion error: {error_msg}'
        }

def process_local_content(content, txt_delimiter=',', param_delimiter='$', direction='m3u2txt', parameters=None):
    """Process local content with dual delimiter"""
    if parameters is None:
        parameters = {}
    
    format_detected = detect_format(content, txt_delimiter, param_delimiter)
    
    if direction == 'm3u2txt':
        if format_detected in ['m3u', 'txt']:
            output, channel_count, group_count = convert_m3u_to_txt(content, txt_delimiter, param_delimiter, parameters)
        else:
            # For other formats, try to convert as m3u
            output, channel_count, group_count = convert_m3u_to_txt(content, txt_delimiter, param_delimiter, parameters)
        
        return {
            'success': True,
            'output': output,
            'channels': channel_count,
            'groups': group_count,
            'format': 'txt',
            'direction': direction,
            'original_format': format_detected,
            'parameters_applied': len(parameters)
        }
    else:
        if format_detected == 'txt':
            output, channel_count, group_count = convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
        else:
            # For other formats, try to convert as txt
            output, channel_count, group_count = convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
        
        return {
            'success': True,
            'output': output,
            'channels': channel_count,
            'groups': group_count,
            'format': 'm3u',
            'direction': direction,
            'original_format': format_detected,
            'parameters_applied': len(parameters)
        }

def convert_to_json(content, txt_delimiter=',', param_delimiter='$', direction='m3u2txt', parameters=None):
    """Convert content to JSON format with dual delimiter"""
    if parameters is None:
        parameters = {}
    
    if direction == 'm3u2txt':
        channels = parse_m3u(content)
    else:
        channels = parse_txt(content, txt_delimiter, param_delimiter)
    
    return json.dumps({
        'channels': channels,
        'count': len(channels),
        'groups': list(set(channel['group'] for channel in channels)),
        'parameters': parameters
    }, indent=2)

def convert_to_m3u8_export(content, txt_delimiter=',', param_delimiter='$', direction='m3u2txt', parameters=None):
    """Export content to M3U8 format (UTF-8 with BOM)"""
    if parameters is None:
        parameters = {}
    
    if direction == 'm3u2txt':
        m3u_content, channel_count, group_count = convert_txt_to_m3u(content, txt_delimiter, param_delimiter, parameters)
        m3u8_content = m3u_content
    else:
        m3u8_content, channel_count, group_count = content, 0, 0
    
    try:
        m3u8_bytes = m3u8_content.encode('utf-8')
        m3u8_with_bom = b'\\xef\\xbb\\xbf' + m3u8_bytes
        return m3u8_with_bom.decode('utf-8'), channel_count, group_count
    except Exception as e:
        return m3u8_content, channel_count, group_count
`;
            
            await pyodide.runPythonAsync(pythonCode);
            logToConsole('Python conversion code loaded! (Dual delimiter + Multi-format + 200MB support)', 'success');
        }
        
        // ========== BATCH MODE FUNCTIONS - OPTIMIZED ==========
        
        // Initialize batch mode
        function initializeBatchMode() {
            batchFilesList = [];
            updateBatchUI();
        }
        
        // Update batch UI
        function updateBatchUI() {
            const hasFiles = batchFilesList.length > 0;
            const readyFiles = batchFilesList.filter(f => f.status === 'ready').length;
            
            batchEmpty.style.display = hasFiles ? 'none' : 'block';
            batchFiles.style.display = hasFiles ? 'block' : 'none';
            batchSummary.style.display = hasFiles ? 'block' : 'none';
            batchActions.style.display = hasFiles ? 'flex' : 'none';
            
            if (hasFiles) {
                updateBatchList();
                
                batchTotalFiles.textContent = batchFilesList.length;
                batchReadyFiles.textContent = readyFiles;
                
                const totalSize = batchFilesList.reduce((sum, file) => sum + file.size, 0);
                batchTotalSize.textContent = formatFileSize(totalSize);
                
                batchOverallStatus.textContent = readyFiles === batchFilesList.length ? 'Ready' : 'Processing';
                
                processBatchBtn.disabled = readyFiles === 0;
                
                // Show performance warning for large batches
                if (totalSize > BATCH_SIZE_WARNING) {
                    batchPerformanceWarning.style.display = 'flex';
                    batchPerformanceWarningText.textContent = `Batch total ${formatFileSize(totalSize)}. Processing may be slow.`;
                } else {
                    batchPerformanceWarning.style.display = 'none';
                }
            } else {
                processBatchBtn.disabled = true;
                batchPerformanceWarning.style.display = 'none';
            }
        }
        
        // Update batch list
        function updateBatchList() {
            batchFiles.innerHTML = '';
            
            batchFilesList.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'batch-file-item';
                fileItem.innerHTML = `
                    <div class="batch-file-info">
                        <i class="fas fa-file-alt" style="color: #60a5fa;"></i>
                        <div class="batch-file-name">${escapeHtml(file.name)}</div>
                        <div class="batch-file-size">${formatFileSize(file.size)}</div>
                    </div>
                    <div class="batch-file-status ${file.status}">${file.status}</div>
                    <button class="batch-file-remove" data-index="${index}" aria-label="Remove file">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                
                batchFiles.appendChild(fileItem);
            });
            
            document.querySelectorAll('.batch-file-remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.currentTarget.dataset.index);
                    removeBatchFile(index);
                });
            });
        }
        
        // Add batch files with all format support and 200MB limit
        function addBatchFiles(files) {
            let addedCount = 0;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                const validation = validateFileSize(file, true);
                if (!validation.valid) {
                    logToConsole(validation.message, 'warning');
                    continue;
                }
                
                const fileExt = getFileExtension(file.name);
                const supportedFormats = ['m3u', 'm3u8', 'txt', 'json', 'xml', 'csv', 'ts', 'mpd', 'list', 'log', 'dat'];
                const isTextFile = file.type.startsWith('text/') || 
                                  file.type === 'application/json' || 
                                  file.type === 'application/xml';
                
                if (!supportedFormats.includes(fileExt) && !isTextFile) {
                    logToConsole(`File "${file.name}" format may not be supported (${fileExt})`, 'warning');
                    // Continue anyway, we'll try to process
                }
                
                batchFilesList.push({
                    file: file,
                    name: file.name,
                    size: file.size,
                    status: 'ready'
                });
                
                addedCount++;
                logToConsole(`File "${file.name}" added to batch (${fileExt}, ${formatFileSize(file.size)})`, 'success');
            }
            
            updateBatchUI();
            
            if (addedCount > 0) {
                showNotification(`${addedCount} files added to batch`, 'info');
            }
        }
        
        // Remove batch file
        function removeBatchFile(index) {
            if (index >= 0 && index < batchFilesList.length) {
                const removedFile = batchFilesList.splice(index, 1)[0];
                logToConsole(`File "${removedFile.name}" removed from batch`, 'info');
                showNotification(`File "${removedFile.name}" removed`, 'info');
                updateBatchUI();
            }
        }
        
        // Process batch files with optimization for large files
        async function processBatchFiles() {
            if (!pyodide || !isPythonLoaded) {
                showNotification('Python runtime not ready', 'error');
                return;
            }
            
            const readyFiles = batchFilesList.filter(f => f.status === 'ready');
            if (readyFiles.length === 0) {
                showNotification('No files ready to process', 'warning');
                return;
            }
            
            // Check memory before processing batch
            const memoryInfo = updateMemoryMonitor();
            if (memoryInfo && memoryInfo.usedPercent > 85) {
                showNotification('Browser memory almost full. Try closing other tabs before processing batch.', 'error');
                return;
            }
            
            statusEl.textContent = 'Processing batch...';
            processBatchBtn.disabled = true;
            batchProgress.style.display = 'block';
            clearConsole();
            
            const txtDelimiter = getTxtDelimiter();
            const paramDelimiter = getParamDelimiter();
            const parameters = getActiveParameters();
            
            const totalSize = readyFiles.reduce((sum, f) => sum + f.size, 0);
            logToConsole(`Processing ${readyFiles.length} files in batch (total: ${formatFileSize(totalSize)})`, 'log');
            logToConsole(`Direction: ${conversionDirection}`, 'log');
            logToConsole(`TXT Delimiter: "${txtDelimiter}", Param Delimiter: "${paramDelimiter}"`, 'log');
            logToConsole(`Parameters: ${JSON.stringify(parameters)}`, 'log');
            updateAriaLive(`Starting batch conversion with ${readyFiles.length} files`);
            
            let processedCount = 0;
            let successfulCount = 0;
            let allResults = [];
            
            batchProgressBar.style.width = '0%';
            batchProgressText.textContent = `0/${readyFiles.length}`;
            batchProgressPercent.textContent = '0%';
            
            for (let i = 0; i < readyFiles.length; i++) {
                const fileObj = readyFiles[i];
                fileObj.status = 'processing';
                updateBatchUI();
                
                try {
                    // Update memory monitor
                    updateMemoryMonitor();
                    
                    const content = await readFileAsText(fileObj.file);
                    const detectedFormat = validateContent(content, fileObj.name);
                    
                    logToConsole(`Processing "${fileObj.name}" (${detectedFormat}, ${formatFileSize(content.length)})...`, 'info');
                    
                    const base64Content = btoa(unescape(encodeURIComponent(content)));
                    
                    const result = await pyodide.runPythonAsync(`
                        import json, base64
                        
                        try:
                            content = base64.b64decode("${base64Content}").decode('utf-8', errors='ignore')
                        except:
                            content = base64.b64decode("${base64Content}").decode('latin-1')
                        
                        result = process_local_content(
                            content, 
                            ${JSON.stringify(txtDelimiter)}, 
                            ${JSON.stringify(paramDelimiter)}, 
                            ${JSON.stringify(conversionDirection)},
                            ${JSON.stringify(parameters)}
                        )
                        
                        # Add original format info
                        import re
                        def detect_format_simple(content):
                            if '#EXTM3U' in content or '#EXTINF:' in content:
                                return 'm3u'
                            elif '#genre#' in content or (',' in content and 'http' in content):
                                return 'txt'
                            elif content.strip().startswith('{') or content.strip().startswith('['):
                                try:
                                    json.loads(content)
                                    return 'json'
                                except:
                                    pass
                            elif content.strip().startsWith('<?xml') or content.strip().startsWith('<'):
                                return 'xml'
                            else:
                                return 'txt'
                        
                        format_detected = detect_format_simple(content)
                        result['original_format'] = format_detected
                        
                        json.dumps(result)
                    `);
                    
                    const data = JSON.parse(result);
                    
                    if (data.success) {
                        fileObj.status = 'success';
                        fileObj.result = data;
                        successfulCount++;
                        allResults.push(data.output);
                        
                        logToConsole(`"${fileObj.name}" processed successfully (${data.channels} channels, format: ${data.original_format})`, 'success');
                    } else {
                        fileObj.status = 'error';
                        fileObj.error = data.error;
                        logToConsole(`"${fileObj.name}" failed: ${data.error}`, 'error');
                    }
                    
                } catch (error) {
                    fileObj.status = 'error';
                    fileObj.error = error.message;
                    logToConsole(`"${fileObj.name}" error: ${error.message}`, 'error');
                }
                
                processedCount++;
                
                const progress = Math.round((processedCount / readyFiles.length) * 100);
                batchProgressBar.style.width = `${progress}%`;
                batchProgressText.textContent = `${processedCount}/${readyFiles.length}`;
                batchProgressPercent.textContent = `${progress}%`;
                
                updateBatchUI();
            }
            
            if (successfulCount > 0) {
                const combinedOutput = allResults.join('\n\n');
                convertedOutput = combinedOutput;
                txtOutput.value = combinedOutput;
                
                const totalChannels = batchFilesList
                    .filter(f => f.status === 'success')
                    .reduce((sum, f) => sum + (f.result?.channels || 0), 0);
                const totalGroups = batchFilesList
                    .filter(f => f.status === 'success')
                    .reduce((sum, f) => sum + (f.result?.groups || 0), 0);
                
                channelCount.textContent = totalChannels;
                groupCount.textContent = totalGroups;
                
                statChannels.textContent = totalChannels;
                statGroups.textContent = totalGroups;
                statLines.textContent = combinedOutput.split('\n').length;
                statsGrid.style.display = 'grid';
                
                downloadBtn.disabled = false;
                copyBtn.disabled = false;
                exportOptions.style.display = 'block';
                
                statusEl.textContent = `Completed (${successfulCount}/${readyFiles.length} files)`;
                emptyState.style.display = 'none';
                resultArea.style.display = 'block';
                
                const detectedFormat = conversionDirection === 'm3u2txt' ? 'txt' : 'm3u';
                manualFormatName.textContent = `Batch Conversion: ${conversionDirection === 'm3u2txt' ? 'M3U â†’ TXT' : 'TXT â†’ M3U'}`;
                manualFormatDesc.textContent = `${successfulCount} files, ${totalChannels} total channels`;
                manualFormatInfo.style.display = 'block';
                
                logToConsole(`Batch processing complete: ${successfulCount}/${readyFiles.length} files successful`, 'success');
                showNotification(`Batch completed: ${successfulCount} files processed successfully!`, 'success');
                updateAriaLive(`Batch processing complete: ${successfulCount} files processed`);
                
            } else {
                statusEl.textContent = 'All files failed';
                showNotification('All files failed to process', 'error');
            }
            
            batchProgress.style.display = 'none';
            batchPerformanceWarning.style.display = 'none';
            processBatchBtn.disabled = false;
        }
        
        // ========== INITIALIZE PYTHON ==========
        
        async function initializePython() {
            loadingEl.classList.add('show');
            loadingText.textContent = 'Checking Pyodide cache...';
            cacheStatus.style.display = 'block';
            cacheStatus.className = 'cache-status loading';
            
            setupCacheExpiration();
            updateConnectionStatus();
            
            let isCached = false;
            let cacheInfo = '0 MB';
            
            try {
                if ('indexedDB' in window) {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('pyodide', 1);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (db.objectStoreNames.contains('pyodide')) {
                        isCached = true;
                        cacheInfo = await estimateCacheSize();
                        cacheDetail.textContent = 'Cache found';
                        footerCacheStatus.textContent = 'Cached';
                        
                        const cachedDate = localStorage.getItem('pyodide_cached_date');
                        if (cachedDate) {
                            const date = new Date(cachedDate);
                            lastCachedDate.textContent = date.toLocaleDateString('en-US');
                        }
                    }
                }
            } catch (e) {
                console.log('Cache check failed:', e);
            }
            
            if (isCached) {
                cacheStatusText.textContent = 'Pyodide found in cache!';
                loadedFromCache.textContent = 'Yes';
                cacheSize.textContent = cacheInfo;
                cacheStatus.className = 'cache-status cached';
                loadingText.textContent = 'Loading from cache...';
                loadingNote.textContent = 'Python runtime loaded from browser cache';
                pythonReadyText.textContent = 'Python runtime ready! (Loaded from cache)';
                firstTimeNote.style.display = 'none';
            } else {
                cacheStatusText.textContent = 'Downloading Pyodide first time...';
                loadedFromCache.textContent = 'No';
                cacheSize.textContent = '~18MB';
                loadingText.textContent = 'Downloading Python runtime...';
                loadingNote.textContent = 'Python runtime (~18MB) will be downloaded once only';
                pythonReadyText.textContent = 'Python runtime ready! (Will be cached for next visit)';
                firstTimeNote.style.display = 'block';
                footerCacheStatus.textContent = 'Not cached';
                lastCachedDate.textContent = 'Never';
            }
            
            try {
                pyodide = await loadPyodide({
                    stdout: (text) => {
                        if (text.includes('Loading') || text.includes('Downloading') || text.includes('%')) {
                            if (text.includes('%')) {
                                const match = text.match(/(\d+)%/);
                                if (match) {
                                    const percent = match[1];
                                    progressFill.style.width = percent + '%';
                                    cacheDetail.textContent = `Downloading ${percent}%`;
                                }
                            }
                        }
                    },
                    stderr: (text) => {
                        console.error('Pyodide error:', text);
                        logToConsole(`Error: ${text}`, 'error');
                    },
                    packages: ['micropip'],
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/",
                    fullStdLib: false,
                });
                
                progressFill.style.width = '30%';
                cacheStatusText.textContent = 'Installing packages...';
                cacheDetail.textContent = 'Installing micropip...';
                
                await pyodide.loadPackage(['micropip']);
                
                progressFill.style.width = '60%';
                cacheStatusText.textContent = 'Installing requests...';
                cacheDetail.textContent = 'Installing requests...';
                
                await retryOperation(async () => {
                    await pyodide.runPythonAsync(`
                        import micropip
                        await micropip.install('requests')
                    `);
                });
                
                progressFill.style.width = '80%';
                cacheStatusText.textContent = 'Loading conversion code...';
                cacheDetail.textContent = 'Loading conversion code...';
                
                await loadPythonCode();
                
                progressFill.style.width = '100%';
                loadingEl.classList.remove('show');
                
                if (isCached) {
                    cacheStatusText.textContent = 'Ready! (Loaded from cache)';
                    cacheDetail.textContent = 'Loaded from cache';
                } else {
                    cacheStatusText.textContent = 'Ready! (Cache saved for next visit)';
                    cacheDetail.textContent = 'Cached for next visit';
                    
                    localStorage.setItem('pyodide_cached', 'true');
                    localStorage.setItem('pyodide_cached_date', new Date().toISOString());
                    
                    footerCacheStatus.textContent = 'Cached';
                    lastCachedDate.textContent = new Date().toLocaleDateString('en-US');
                }
                
                setTimeout(async () => {
                    const newSize = await estimateCacheSize();
                    cacheSize.textContent = newSize;
                }, 1000);
                
                cacheActions.style.display = 'flex';
                pythonReady.style.display = 'flex';
                statusEl.textContent = 'Python ready!';
                isPythonLoaded = true;
                
                logToConsole('Python runtime ready to use! (Dual delimiter + Multi-format + 200MB support)', 'success');
                showNotification(isCached ? 
                    'Python loaded from cache! Instant load!' : 
                    'Python runtime successfully loaded! Cache saved.', 'info');
                updateAriaLive('Python runtime ready to use');
                
                fetchBtn.disabled = false;
                convertWithPythonBtn.disabled = false;
                testConnectionBtn.disabled = false;
                processManualBtn.disabled = false;
                processBatchBtn.disabled = batchFilesList.filter(f => f.status === 'ready').length === 0;
                directDownloadBtn.disabled = false;
                analyzeParamsBtn.disabled = false;
                applyFilterBtn.disabled = false;
                addNewParamBtn.disabled = false;
                checkAllParamsBtn.disabled = false;
                uncheckAllParamsBtn.disabled = false;
                enableAllParamsBtn.disabled = false;
                disableAllParamsBtn.disabled = false;
                
                processFileBtn.disabled = selectedFile === null;
                
                // Start memory monitor
                setInterval(updateMemoryMonitor, 5000);
                
            } catch (error) {
                console.error('Failed to load Pyodide:', error);
                cacheStatusText.textContent = 'Error loading Pyodide';
                cacheDetail.textContent = 'Error: ' + error.message;
                cacheStatus.className = 'cache-status error';
                logToConsole(`ERROR: ${error.message}`, 'error');
                statusEl.textContent = 'Error loading Python';
                showNotification('Failed to load Python runtime', 'error');
                updateAriaLive('Failed to load Python runtime');
                
                errorDetailsText.textContent = `Error: ${error.message}`;
                errorDetails.style.display = 'block';
                retryButton.style.display = 'block';
                retryButton.onclick = () => {
                    errorDetails.style.display = 'none';
                    retryButton.style.display = 'none';
                    initializePython();
                };
            }
        }
        
        // ========== SET CONVERSION DIRECTION ==========
        
        // Set conversion direction
        function setConversionDirection(direction) {
            conversionDirection = direction;
            
            directionBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.direction === direction) {
                    btn.classList.add('active');
                }
            });
            
            if (direction === 'm3u2txt') {
                conversionModeText.textContent = 'M3U â†’ TXT';
                dropAreaText.textContent = 'Drag & Drop Playlist File (Max 200MB)';
                txtExample.style.display = 'none';
            } else {
                conversionModeText.textContent = 'TXT â†’ M3U';
                dropAreaText.textContent = 'Drag & Drop Playlist File (Max 200MB)';
                txtExample.style.display = 'block';
            }
            
            clearOutput();
            showNotification(`Mode changed to: ${direction === 'm3u2txt' ? 'M3U â†’ TXT' : 'TXT â†’ M3U'}`, 'info');
            updateAriaLive(`Conversion mode changed to ${direction === 'm3u2txt' ? 'M3U to TXT' : 'TXT to M3U'}`);
        }
        
        // Set current mode
        function setMode(mode) {
            currentMode = mode;
            
            modeBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
            
            urlMode.style.display = mode === 'url' ? 'block' : 'none';
            fileMode.style.display = mode === 'file' ? 'block' : 'none';
            manualMode.style.display = mode === 'manual' ? 'block' : 'none';
            batchMode.style.display = mode === 'batch' ? 'block' : 'none';
            batchProcessing.style.display = mode === 'batch' ? 'block' : 'none';
            
            formatInfo.style.display = 'none';
            fileFormatInfo.style.display = 'none';
            manualFormatInfo.style.display = 'none';
            performanceWarning.style.display = 'none';
            batchPerformanceWarning.style.display = 'none';
            
            clearOutput();
            updateAriaLive(`Mode changed to ${mode}`);
        }
        
        // Clear output
        function clearOutput() {
            convertedOutput = '';
            txtOutput.value = '';
            downloadBtn.disabled = true;
            copyBtn.disabled = true;
            exportOptions.style.display = 'none';
            statsGrid.style.display = 'none';
            emptyState.style.display = 'block';
            resultArea.style.display = 'none';
            formatInfo.style.display = 'none';
            fileFormatInfo.style.display = 'none';
            manualFormatInfo.style.display = 'none';
            errorDetails.style.display = 'none';
            directDownloadInfo.style.display = 'none';
            filterStatus.style.display = 'none';
            performanceWarning.style.display = 'none';
        }
        
        // Update UI after conversion
        function updateUIAfterConversion(data) {
            if (data.success) {
                convertedOutput = data.output;
                txtOutput.value = convertedOutput;
                
                channelCount.textContent = data.channels || 0;
                groupCount.textContent = data.groups || 0;
                
                statChannels.textContent = data.channels || 0;
                statGroups.textContent = data.groups || 0;
                statLines.textContent = convertedOutput.split('\n').length;
                statsGrid.style.display = 'grid';
                
                downloadBtn.disabled = false;
                copyBtn.disabled = false;
                exportOptions.style.display = 'block';
                
                const directionText = data.direction === 'm3u2txt' ? 'M3U â†’ TXT' : 'TXT â†’ M3U';
                const paramsText = data.parameters_applied ? ` (${data.parameters_applied} parameters)` : '';
                const formatText = data.original_format ? ` [${data.original_format.toUpperCase()}]` : '';
                statusEl.textContent = `Completed (${directionText}${formatText}${paramsText})`;
                emptyState.style.display = 'none';
                resultArea.style.display = 'block';
                
                const detectedFormat = data.format || 'unknown';
                const originalFormat = data.original_format || 'unknown';
                
                if (currentMode === 'url') {
                    formatName.textContent = `Conversion: ${originalFormat.toUpperCase()} â†’ ${detectedFormat.toUpperCase()}`;
                    formatDesc.textContent = `${data.channels} channels, ${data.groups} groups${data.parameters_applied ? `, ${data.parameters_applied} parameters` : ''}`;
                    formatInfo.style.display = 'block';
                } else if (currentMode === 'file') {
                    fileFormatName.textContent = `Conversion: ${originalFormat.toUpperCase()} â†’ ${detectedFormat.toUpperCase()}`;
                    fileFormatDesc.textContent = `${data.channels} channels, ${data.groups} groups${data.parameters_applied ? `, ${data.parameters_applied} parameters` : ''}`;
                    fileFormatInfo.style.display = 'block';
                } else {
                    manualFormatName.textContent = `Conversion: ${originalFormat.toUpperCase()} â†’ ${detectedFormat.toUpperCase()}`;
                    manualFormatDesc.textContent = `${data.channels} channels, ${data.groups} groups${data.parameters_applied ? `, ${data.parameters_applied} parameters` : ''}`;
                    manualFormatInfo.style.display = 'block';
                }
                
                logToConsole(`Success! ${data.channels} channels in ${data.groups} groups${data.parameters_applied ? ` with ${data.parameters_applied} parameters` : ''}`, 'success');
                showNotification(`Conversion successful! ${data.channels} channels${data.parameters_applied ? ` with ${data.parameters_applied} parameters` : ''}`);
                updateAriaLive(`Conversion successful. ${data.channels} channels, ${data.groups} groups`);
                
                updateMemoryMonitor();
            } else {
                logToConsole(`ERROR: ${data.error}`, 'error');
                statusEl.textContent = 'Error';
                showNotification(`Failed: ${data.error}`, 'error');
                updateAriaLive(`Error: ${data.error}`);
                
                errorDetailsText.textContent = `Error: ${data.error}`;
                errorDetails.style.display = 'block';
            }
        }
        
        // ========== FETCH AND CONVERT FUNCTIONS ==========
        
        // Fetch from URL with dual delimiter support
        async function fetchFromURL() {
            if (!pyodide || !isPythonLoaded) {
                showNotification('Python runtime not ready', 'error');
                return;
            }
            
            const url = urlInput.value.trim();
            const txtDelimiter = getTxtDelimiter();
            const paramDelimiter = getParamDelimiter();
            const method = getSelectedProxyMethod();
            const parameters = getActiveParameters();
            
            if (!url) {
                showNotification('Enter playlist URL', 'error');
                return;
            }
            
            if (!isValidUrl(url)) {
                showNotification('Invalid URL', 'error');
                return;
            }
            
            statusEl.textContent = 'Processing...';
            fetchBtn.disabled = true;
            convertWithPythonBtn.disabled = true;
            clearConsole();
            
            logToConsole(`Processing URL: ${url}`, 'log');
            logToConsole(`Direction: ${conversionDirection}, Method: ${method}`, 'log');
            logToConsole(`TXT Delimiter: "${txtDelimiter}", Param Delimiter: "${paramDelimiter}"`, 'log');
            logToConsole(`Parameters: ${JSON.stringify(parameters)}`, 'log');
            updateAriaLive('Starting conversion from URL');
            
            try {
                const result = await retryOperation(async () => {
                    return await pyodide.runPythonAsync(`
                        import json
                        result = fetch_and_convert(
                            ${JSON.stringify(url)}, 
                            ${JSON.stringify(txtDelimiter)}, 
                            ${JSON.stringify(paramDelimiter)}, 
                            ${JSON.stringify(method)}, 
                            ${JSON.stringify(conversionDirection)},
                            ${JSON.stringify(parameters)}
                        )
                        json.dumps(result)
                    `);
                });
                
                const data = JSON.parse(result);
                logToConsole(`Python function completed`, 'success');
                
                updateUIAfterConversion(data);
                
            } catch (error) {
                console.error('Conversion error:', error);
                logToConsole(`ERROR: ${error.message}`, 'error');
                statusEl.textContent = 'Error';
                showNotification(`Failed: ${error.message}`, 'error');
                updateAriaLive(`Error: ${error.message}`);
                
                errorDetailsText.textContent = `Error: ${error.message}`;
                errorDetails.style.display = 'block';
                retryButton.style.display = 'block';
                retryButton.onclick = () => {
                    errorDetails.style.display = 'none';
                    retryButton.style.display = 'none';
                    fetchFromURL();
                };
            } finally {
                fetchBtn.disabled = false;
                convertWithPythonBtn.disabled = false;
            }
        }
        
        // ========== MANUAL MODE FUNCTIONS ==========
        
        // Process manual input with Python
        async function processManualInput() {
            if (!pyodide || !isPythonLoaded) {
                showNotification('Python runtime not ready', 'error');
                return;
            }
            
            const content = manualInput.value.trim();
            const txtDelimiter = getTxtDelimiter();
            const paramDelimiter = getParamDelimiter();
            const parameters = getActiveParameters();
            
            if (!content) {
                showNotification('Enter content first', 'error');
                return;
            }
            
            try {
                validateContent(content);
            } catch (error) {
                logToConsole(`Content validation error: ${error.message}`, 'error');
                showNotification(`Error: ${error.message}`, 'error');
                return;
            }
            
            statusEl.textContent = 'Processing manual input...';
            processManualBtn.disabled = true;
            clearConsole();
            
            logToConsole(`Processing manual input`, 'log');
            logToConsole(`Direction: ${conversionDirection}`, 'log');
            logToConsole(`TXT Delimiter: "${txtDelimiter}", Param Delimiter: "${paramDelimiter}"`, 'log');
            logToConsole(`Parameters: ${JSON.stringify(parameters)}`, 'log');
            updateAriaLive('Starting manual input conversion');
            
            try {
                const base64Content = btoa(unescape(encodeURIComponent(content)));
                
                const result = await retryOperation(async () => {
                    return await pyodide.runPythonAsync(`
                        import json, base64
                        
                        try:
                            content = base64.b64decode("${base64Content}").decode('utf-8', errors='ignore')
                        except:
                            content = base64.b64decode("${base64Content}").decode('latin-1')
                        
                        result = process_local_content(
                            content, 
                            ${JSON.stringify(txtDelimiter)}, 
                            ${JSON.stringify(paramDelimiter)}, 
                            ${JSON.stringify(conversionDirection)},
                            ${JSON.stringify(parameters)}
                        )
                        json.dumps(result)
                    `);
                });
                
                const data = JSON.parse(result);
                logToConsole(`Python function completed`, 'success');
                
                updateUIAfterConversion(data);
                
            } catch (error) {
                console.error('Manual conversion error:', error);
                logToConsole(`ERROR: ${error.message}`, 'error');
                statusEl.textContent = 'Error';
                showNotification(`Failed: ${error.message}`, 'error');
                updateAriaLive(`Error: ${error.message}`);
                
                errorDetailsText.textContent = `Error: ${error.message}`;
                errorDetails.style.display = 'block';
                retryButton.style.display = 'block';
                retryButton.onclick = () => {
                    errorDetails.style.display = 'none';
                    retryButton.style.display = 'none';
                    processManualInput();
                };
            } finally {
                processManualBtn.disabled = false;
            }
        }
        
        // ========== DIRECT DOWNLOAD FUNCTION ==========
        
        // Direct download function
        async function directDownloadFile() {
            const url = urlInput.value.trim();
            if (!url) {
                showNotification('Enter URL first', 'error');
                return;
            }
            
            if (!isValidUrl(url)) {
                showNotification('Invalid URL', 'error');
                return;
            }
            
            directDownloadInfo.style.display = 'block';
            downloadStatus.textContent = 'Starting download...';
            downloadProgress.style.width = '0%';
            directDownloadBtn.disabled = true;
            convertWithPythonBtn.disabled = true;
            
            try {
                currentDownloadController = new AbortController();
                const signal = currentDownloadController.signal;
                
                const response = await fetch(url, { signal });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const contentLength = response.headers.get('content-length');
                const total = contentLength ? parseInt(contentLength) : 0;
                let loaded = 0;
                
                const reader = response.body.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    loaded += value.length;
                    
                    if (total > 0) {
                        const progress = Math.round((loaded / total) * 100);
                        downloadProgress.style.width = `${progress}%`;
                        downloadStatus.textContent = `Downloading: ${progress}%`;
                    } else {
                        downloadStatus.textContent = `Downloading: ${formatFileSize(loaded)}`;
                    }
                }
                
                const blob = new Blob(chunks);
                const filename = url.split('/').pop() || 'download.m3u';
                
                const blobUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(blobUrl);
                
                downloadProgress.style.width = '100%';
                downloadStatus.textContent = 'Download completed!';
                
                logToConsole(`Direct download completed: ${filename} (${formatFileSize(loaded)})`, 'success');
                showNotification(`File "${filename}" downloaded successfully!`, 'success');
                updateAriaLive(`File ${filename} downloaded successfully`);
                
                setTimeout(() => {
                    directDownloadInfo.style.display = 'none';
                }, 3000);
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    logToConsole('Download cancelled', 'warning');
                    showNotification('Download cancelled', 'warning');
                } else {
                    logToConsole(`Download error: ${error.message}`, 'error');
                    showNotification(`Download failed: ${error.message}`, 'error');
                }
                
                downloadStatus.textContent = `Error: ${error.message}`;
                downloadProgress.style.backgroundColor = '#ef4444';
            } finally {
                directDownloadBtn.disabled = false;
                convertWithPythonBtn.disabled = false;
                currentDownloadController = null;
            }
        }
        
        // ========== EVENT LISTENERS ==========
        
        // Initialize event listeners for all modes
        function initializeEventListeners() {
            // Mode switching
            modeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    setMode(btn.dataset.mode);
                    showNotification(`Mode changed to: ${btn.dataset.mode.toUpperCase()}`, 'info');
                });
            });
            
            // Direction switching
            directionBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    setConversionDirection(btn.dataset.direction);
                });
            });
            
            // Delimiter change events
            txtDelimiterSelect.addEventListener('change', () => {
                saveDelimiterSettings();
                logToConsole(`TXT delimiter changed to: ${txtDelimiterSelect.value}`, 'info');
            });
            
            paramDelimiterSelect.addEventListener('change', () => {
                updateParamDelimiterDisplay();
                saveDelimiterSettings();
                logToConsole(`Parameter delimiter changed to: ${paramDelimiterSelect.value}`, 'info');
            });
            
            // URL Mode
            urlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && isPythonLoaded) {
                    fetchFromURL();
                }
            });
            
            fetchBtn.addEventListener('click', fetchFromURL);
            convertWithPythonBtn.addEventListener('click', fetchFromURL);
            
            // Test connection button
            testConnectionBtn.addEventListener('click', async () => {
                if (!pyodide || !isPythonLoaded) {
                    showNotification('Python runtime not ready', 'error');
                    return;
                }
                
                const url = urlInput.value.trim();
                if (!url) {
                    showNotification('Enter URL first', 'error');
                    return;
                }
                
                if (!isValidUrl(url)) {
                    showNotification('Invalid URL', 'error');
                    return;
                }
                
                statusEl.textContent = 'Testing connection...';
                testConnectionBtn.disabled = true;
                clearConsole();
                
                logToConsole(`Testing connection to: ${url}`, 'log');
                updateAriaLive('Testing connection');
                
                try {
                    const testCode = `
import requests
import json
import urllib.parse

def test_connection(url):
    results = []
    
    try:
        headers = {'User-Agent': 'Mozilla/5.0'}
        resp = requests.get(url, headers=headers, timeout=5)
        results.append({
            'method': 'direct',
            'status': resp.status_code,
            'success': resp.status_code == 200
        })
    except Exception as e:
        results.append({
            'method': 'direct',
            'status': 'error',
            'error': str(e)
        })
    
    try:
        encoded = urllib.parse.quote(url, safe='')
        proxy_url = f"https://corsproxy.io/?{encoded}"
        resp = requests.get(proxy_url, timeout=5)
        results.append({
            'method': 'corsproxy',
            'status': resp.status_code,
            'success': resp.status_code == 200
        })
    except Exception as e:
        results.append({
            'method': 'corsproxy',
            'status': 'error',
            'error': str(e)
        })
    
    return json.dumps(results)
    
test_connection(${JSON.stringify(url)})
`;
                    
                    const result = await retryOperation(async () => {
                        return await pyodide.runPythonAsync(testCode);
                    });
                    
                    const results = JSON.parse(result);
                    
                    logToConsole('Connection test results:', 'log');
                    results.forEach(res => {
                        if (res.success) {
                            logToConsole(`âœ“ ${res.method}: Success (status ${res.status})`, 'success');
                        } else {
                            logToConsole(`âœ— ${res.method}: Failed (${res.error || 'status ' + res.status})`, 'error');
                        }
                    });
                    
                    const bestMethod = results.find(r => r.success)?.method || 'direct';
                    logToConsole(`Recommendation: Use "${bestMethod}" method`, 'success');
                    
                    const radioBtn = document.querySelector(`input[value="${bestMethod}"]`);
                    if (radioBtn) radioBtn.checked = true;
                    
                    statusEl.textContent = 'Test completed';
                    showNotification(`Connection test completed. Recommendation: ${bestMethod}`, 'info');
                    updateAriaLive(`Connection test completed. Recommendation: ${bestMethod}`);
                    
                } catch (error) {
                    logToConsole(`ERROR: ${error.message}`, 'error');
                    statusEl.textContent = 'Test error';
                    showNotification('Connection test failed', 'error');
                    updateAriaLive('Connection test failed');
                } finally {
                    testConnectionBtn.disabled = false;
                }
            });
            
            // Download button
            downloadBtn.addEventListener('click', () => {
                if (!convertedOutput) return;
                
                const timestamp = new Date().toISOString().slice(0,10).replace(/-/g, '');
                const fileExt = conversionDirection === 'm3u2txt' ? '.txt' : '.m3u';
                const fileName = `converted_${timestamp}${fileExt}`;
                
                const blob = new Blob([convertedOutput], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification(`File ${fileName} downloaded successfully!`);
                updateAriaLive(`File ${fileName} downloaded`);
            });
            
            // Clear button
            clearBtn.addEventListener('click', () => {
                clearOutput();
                clearConsole();
                showNotification('Output cleared');
                updateAriaLive('Output cleared');
            });
            
            // Copy button
            copyBtn.addEventListener('click', async () => {
                if (!convertedOutput) {
                    showNotification('No content to copy', 'warning');
                    return;
                }
                
                const success = await copyToClipboard(convertedOutput);
                
                if (success) {
                    copyBtn.classList.add('copy-success');
                    copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    showNotification('Text successfully copied to clipboard!', 'success');
                    updateAriaLive('Text successfully copied to clipboard');
                    
                    setTimeout(() => {
                        copyBtn.classList.remove('copy-success');
                        copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
                    }, 2000);
                } else {
                    showNotification('Failed to copy text. Try copying manually.', 'error');
                    updateAriaLive('Failed to copy text');
                }
            });
            
            // Cache actions
            refreshCacheBtn.addEventListener('click', () => {
                checkCacheStatus();
            });
            
            clearCacheBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear Pyodide cache?\n\nThis will delete Python files (~18MB) from your browser, and will be downloaded again when you refresh the page.')) {
                    clearPyodideCache();
                }
            });
            
            checkCacheBtn.addEventListener('click', () => {
                checkCacheStatus();
            });
            
            // File Mode
            browseBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFileSelection(file);
                }
            });
            
            processFileBtn.addEventListener('click', () => {
                if (selectedFile) {
                    processFileWithPython();
                } else {
                    showNotification('Select file first', 'error');
                }
            });
            
            // Remove file button
            removeFileBtn.addEventListener('click', () => {
                removeSelectedFile();
            });
            
            // Drag and drop for File Mode
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('dragover');
            });
            
            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('dragover');
            });
            
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    fileInput.files = e.dataTransfer.files;
                    handleFileSelection(file);
                }
            });
            
            // Manual Mode
            processManualBtn.addEventListener('click', processManualInput);
            
            manualInput.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && isPythonLoaded) {
                    e.preventDefault();
                    processManualInput();
                }
            });
            
            // Batch Mode
            batchBrowseBtn.addEventListener('click', () => {
                batchFileInput.click();
            });
            
            batchFileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    addBatchFiles(files);
                }
            });
            
            processBatchBtn.addEventListener('click', processBatchFiles);
            
            batchClearBtn.addEventListener('click', () => {
                if (batchFilesList.length > 0) {
                    if (confirm(`Remove all ${batchFilesList.length} files from batch?`)) {
                        batchFilesList = [];
                        updateBatchUI();
                        showNotification('All files removed from batch', 'info');
                    }
                }
            });
            
            // Drag and drop for Batch Mode
            batchDropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                batchDropArea.classList.add('dragover');
            });
            
            batchDropArea.addEventListener('dragleave', () => {
                batchDropArea.classList.remove('dragover');
            });
            
            batchDropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                batchDropArea.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    addBatchFiles(files);
                }
            });
            
            // Direct download
            directDownloadBtn.addEventListener('click', directDownloadFile);
            
            cancelDownloadBtn.addEventListener('click', () => {
                if (currentDownloadController) {
                    currentDownloadController.abort();
                    directDownloadInfo.style.display = 'none';
                    showNotification('Download cancelled', 'warning');
                }
            });
            
            // Copy fallback modal
            copySelectAllBtn.addEventListener('click', () => {
                copyFallbackTextarea.select();
                copyFallbackTextarea.setSelectionRange(0, 99999);
            });
            
            copyCloseBtn.addEventListener('click', () => {
                copyFallback.style.display = 'none';
            });
            
            // Close copy fallback modal with ESC
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && copyFallback.style.display === 'flex') {
                    copyFallback.style.display = 'none';
                }
            });
            
            // Close copy fallback modal with click outside
            copyFallback.addEventListener('click', (e) => {
                if (e.target === copyFallback) {
                    copyFallback.style.display = 'none';
                }
            });
            
            // Export buttons
            exportButtons.forEach(btn => {
                btn.addEventListener('click', async () => {
                    if (!convertedOutput) return;
                    
                    const format = btn.dataset.format;
                    const timestamp = new Date().toISOString().slice(0,10).replace(/-/g, '');
                    const parameters = getActiveParameters();
                    let output = convertedOutput;
                    let fileName = `converted_${timestamp}`;
                    let mimeType = 'text/plain;charset=utf-8';
                    
                    try {
                        if (format === 'json') {
                            const result = await pyodide.runPythonAsync(`
                                import json
                                result = convert_to_json(
                                    ${JSON.stringify(convertedOutput)}, 
                                    ${JSON.stringify(getTxtDelimiter())}, 
                                    ${JSON.stringify(getParamDelimiter())}, 
                                    ${JSON.stringify(conversionDirection)},
                                    ${JSON.stringify(parameters)}
                                )
                                json.dumps({'output': result})
                            `);
                            const data = JSON.parse(result);
                            output = data.output;
                            fileName += '.json';
                            mimeType = 'application/json';
                        } else if (format === 'm3u8') {
                            const result = await pyodide.runPythonAsync(`
                                import json
                                result = convert_to_m3u8_export(
                                    ${JSON.stringify(convertedOutput)}, 
                                    ${JSON.stringify(getTxtDelimiter())}, 
                                    ${JSON.stringify(getParamDelimiter())}, 
                                    ${JSON.stringify(conversionDirection)},
                                    ${JSON.stringify(parameters)}
                                )
                                json.dumps({'output': result})
                            `);
                            const data = JSON.parse(result);
                            output = data.output;
                            fileName += '.m3u8';
                            mimeType = 'application/vnd.apple.mpegurl; charset=utf-8';
                            
                            logToConsole('Exported as M3U8 (UTF-8 with BOM)', 'success');
                            showNotification('Exported as M3U8 (UTF-8 encoded)', 'info');
                        } else if (format === 'm3u') {
                            fileName += '.m3u';
                            mimeType = 'audio/x-mpegurl';
                        } else {
                            fileName += '.txt';
                        }
                        
                        const blob = new Blob([output], { type: mimeType });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        showNotification(`File ${fileName} exported successfully!`);
                        updateAriaLive(`File exported as ${format}`);
                        
                    } catch (error) {
                        logToConsole(`Error exporting to ${format}: ${error.message}`, 'error');
                        showNotification(`Failed to export to ${format}`, 'error');
                        
                        if (format === 'm3u8') {
                            try {
                                const blob = new Blob([convertedOutput], { type: 'audio/x-mpegurl' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = fileName.replace('.m3u8', '.m3u');
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                                
                                showNotification('Exported as M3U (fallback)', 'info');
                                logToConsole('Fallback to M3U successful', 'info');
                            } catch (fallbackError) {
                                logToConsole(`Fallback also failed: ${fallbackError.message}`, 'error');
                            }
                        }
                    }
                });
            });
            
            // URL examples click
            document.querySelectorAll('.url-list li').forEach(li => {
                li.addEventListener('click', () => {
                    if (li.dataset.input) {
                        setMode('manual');
                        const decodedInput = li.dataset.input
                            .replace(/&#10;/g, '\n')
                            .replace(/&quot;/g, '"')
                            .replace(/&amp;/g, '&');
                        manualInput.value = decodedInput;
                        showNotification(`Example playlist loaded to manual mode`);
                        updateAriaLive('Example playlist loaded');
                    }
                });
                
                li.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        li.click();
                    }
                });
            });
            
            // Parameter options event listeners
            parameterSearch.addEventListener('input', () => {
                updateParameterList();
            });
            
            checkAllParamsBtn.addEventListener('click', checkAllParameters);
            uncheckAllParamsBtn.addEventListener('click', uncheckAllParameters);
            enableAllParamsBtn.addEventListener('click', enableAllParameters);
            disableAllParamsBtn.addEventListener('click', disableAllParameters);
            
            addNewParamBtn.addEventListener('click', addNewParameter);
            
            newParamKey.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    newParamValue.focus();
                }
            });
            
            newParamValue.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addNewParameter();
                }
            });
        }
        
        // ========== PWA INITIALIZATION ==========
        
        // Initialize PWA
        function initializePWA() {
            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('App is running as PWA');
                pwaInstall.style.display = 'none';
                document.body.classList.add('pwa-installed');
            }
            
            window.addEventListener('beforeinstallprompt', (e) => {
                console.log('beforeinstallprompt event fired');
                
                e.preventDefault();
                deferredPrompt = e;
                pwaInstall.style.display = 'flex';
                
                setTimeout(() => {
                    installToast.classList.add('show');
                }, 3000);
                
                logToConsole('App can be installed to homescreen!', 'success');
                showNotification('Click "Add to Home Screen" to install app!', 'info');
            });
            
            window.addEventListener('appinstalled', (evt) => {
                console.log('App was installed successfully!');
                pwaInstall.style.display = 'none';
                installToast.classList.remove('show');
                deferredPrompt = null;
                
                logToConsole('App successfully installed!', 'success');
                showNotification('App successfully added to homescreen! ðŸŽ‰', 'success');
            });
            
            installToastClose.addEventListener('click', () => {
                installToast.classList.remove('show');
            });
            
            pwaInstall.addEventListener('click', async () => {
                if (!deferredPrompt) return;
                
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                
                console.log(`User ${outcome} the install prompt`);
                
                if (outcome === 'accepted') {
                    logToConsole('User accepted PWA install', 'success');
                } else {
                    logToConsole('User dismissed PWA install', 'warning');
                }
                
                deferredPrompt = null;
                pwaInstall.style.display = 'none';
                installToast.classList.remove('show');
            });
        }
        
        // ========== NOTIFICATION FUNCTION ==========
        
        // Notification function
        function showNotification(message, type = 'info') {
            notification.textContent = message;
            notification.className = 'notification';
            
            if (type === 'error') {
                notification.classList.add('error');
            } else if (type === 'info') {
                notification.classList.add('info');
            } else if (type === 'warning') {
                notification.classList.add('warning');
            } else if (type === 'success') {
                notification.classList.add('success');
            } else {
                notification.classList.remove('error');
            }
            
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
        
        // ========== INITIALIZE APP ==========
        
        window.addEventListener('load', () => {
            initializePWA();
            initializeParameterOptions();
            setupParameterSearch();
            setFilterMode('keep');
            setFilterScope('all');
            setMode('url');
            setConversionDirection('m3u2txt');
            initializeBatchMode();
            initializeEventListeners();
            
            window.addEventListener('online', updateConnectionStatus);
            window.addEventListener('offline', updateConnectionStatus);
            
            setInterval(updateMemoryMonitor, 10000);
            
            initializePython();
            
            urlInput.focus();
            
            logToConsole('M3U/TXT Converter started - 200MB SUPPORT! ðŸš€', 'success');
            logToConsole('Dual Delimiter: TXT delimiter for channel-URL, Parameter delimiter for URL params', 'info');
            logToConsole(`Current delimiters: TXT="${getTxtDelimiter()}", Param="${getParamDelimiter()}"`, 'info');
            logToConsole('Multi-Format Support: M3U, TXT, JSON, XML, CSV, TS, MPD, etc.', 'info');
            logToConsole('File Mode: Upload any playlist/text file (Max 200MB)', 'info');
            logToConsole('Batch Mode: Process multiple files (Max 200MB/file, 500MB total)', 'info');
            logToConsole('Parameter Filter Options system initialized', 'success');
            updateAriaLive('M3U/TXT Converter app started with Dual Delimiter and 200MB support.');
            
            setTimeout(() => {
                if (deferredPrompt && !window.matchMedia('(display-mode: standalone)').matches) {
                    showNotification('Click "Add to Home Screen" to install app!', 'info');
                }
            }, 3000);
            
            loadDelimiterSettings();
        });
        
        window.addEventListener('beforeunload', () => {
            if (pyodide) {
                pyodide = null;
            }
            
            saveParameterOptions();
            saveDelimiterSettings();
        });
    </script>
</body>
</html>